<!DOCTYPE html>
<html lang="zh-cn"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    
    
    <title>动漫 - 元视角</title>
    <meta name="description" content="">
    
    
    <link rel="shortcut icon" href="" type="image/x-icon">
    
    
    <meta property="og:title" content="动漫">
    <meta property="og:description" content="">
    <meta property="og:type" content="article">
    <meta property="og:url" content="http://localhost:1313/tags/%E5%8A%A8%E6%BC%AB/">
    
    
    <link rel="stylesheet" href="/css/style.css">
    
    
    <link rel="stylesheet" href="/scss/main.min.db8066b82ee922a52a9d5d12ec0d12015500654e6cf423d60210d1b3f9f543cd.css">
    <link rel="stylesheet" href="//at.alicdn.com/t/font_3159629_2j0vwz8wd1k.css">
    
    
    <script src="/js/banner.js" defer></script>
    
    
    <link rel="alternate" type="application/rss+xml" href="http://localhost:1313/tags/%E5%8A%A8%E6%BC%AB/index.xml" title="元视角" />
    
    

    <link crossorigin="" rel="preconnect" href="https://s1.hdslb.com">
    <link crossorigin="" rel="preconnect" href="https://mirrors.sustech.edu.cn">
    <link crossorigin="anonymous" rel="stylesheet" href="https://s1.hdslb.com/bfs/static/jinkela/long/font/regular.css">
    <link crossorigin="anonymous" rel="stylesheet" href="https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/lxgw-wenkai-screen-webfont/1.7.0/style.css">
    <link crossorigin="anonymous" rel="stylesheet" href="https://cdn2.codesign.qq.com/icons/g5ZpEgx3z4VO6j2/latest/iconfont.css">
    <link rel="preconnect" href="https://use.sevencdn.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
    <link crossorigin="anonymous" href="https://use.sevencdn.com/css2?family=Fira+Code:wght@300..700&amp;display=swap" rel="stylesheet">
    <link href="https://X5EBEZB53I-dsn.algolia.net" rel="preconnect" crossorigin="">
</head> <body><div class="background">
    
    <div class="bg-mask"></div>
    
    
    <div class="bg-image" style="background-image: url('https://tuapi.eees.cc/api.php?category=%7bdongman,fengjing%7d&amp;type=302')"></div>
    
    
    
</div> 

<style>
    .background {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: -2;
      &.patterns {
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='192' height='192' viewBox='0 0 192 192'%3E%3Cpath fill='%23494849' fill-opacity='0.08' d='M192 15v2a11 11 0 0 0-11 11c0 1.94 1.16 4.75 2.53 6.11l2.36 2.36a6.93 6.93 0 0 1 1.22 7.56l-.43.84a8.08 8.08 0 0 1-6.66 4.13H145v35.02a6.1 6.1 0 0 0 3.03 4.87l.84.43c1.58.79 4 .4 5.24-.85l2.36-2.36a12.04 12.04 0 0 1 7.51-3.11 13 13 0 1 1 .02 26 12 12 0 0 1-7.53-3.11l-2.36-2.36a4.93 4.93 0 0 0-5.24-.85l-.84.43a6.1 6.1 0 0 0-3.03 4.87V143h35.02a8.08 8.08 0 0 1 6.66 4.13l.43.84a6.91 6.91 0 0 1-1.22 7.56l-2.36 2.36A10.06 10.06 0 0 0 181 164a11 11 0 0 0 11 11v2a13 13 0 0 1-13-13 12 12 0 0 1 3.11-7.53l2.36-2.36a4.93 4.93 0 0 0 .85-5.24l-.43-.84a6.1 6.1 0 0 0-4.87-3.03H145v35.02a8.08 8.08 0 0 1-4.13 6.66l-.84.43a6.91 6.91 0 0 1-7.56-1.22l-2.36-2.36A10.06 10.06 0 0 0 124 181a11 11 0 0 0-11 11h-2a13 13 0 0 1 13-13c2.47 0 5.79 1.37 7.53 3.11l2.36 2.36a4.94 4.94 0 0 0 5.24.85l.84-.43a6.1 6.1 0 0 0 3.03-4.87V145h-35.02a8.08 8.08 0 0 1-6.66-4.13l-.43-.84a6.91 6.91 0 0 1 1.22-7.56l2.36-2.36A10.06 10.06 0 0 0 107 124a11 11 0 0 0-22 0c0 1.94 1.16 4.75 2.53 6.11l2.36 2.36a6.93 6.93 0 0 1 1.22 7.56l-.43.84a8.08 8.08 0 0 1-6.66 4.13H49v35.02a6.1 6.1 0 0 0 3.03 4.87l.84.43c1.58.79 4 .4 5.24-.85l2.36-2.36a12.04 12.04 0 0 1 7.51-3.11A13 13 0 0 1 81 192h-2a11 11 0 0 0-11-11c-1.94 0-4.75 1.16-6.11 2.53l-2.36 2.36a6.93 6.93 0 0 1-7.56 1.22l-.84-.43a8.08 8.08 0 0 1-4.13-6.66V145H11.98a6.1 6.1 0 0 0-4.87 3.03l-.43.84c-.79 1.58-.4 4 .85 5.24l2.36 2.36a12.04 12.04 0 0 1 3.11 7.51A13 13 0 0 1 0 177v-2a11 11 0 0 0 11-11c0-1.94-1.16-4.75-2.53-6.11l-2.36-2.36a6.93 6.93 0 0 1-1.22-7.56l.43-.84a8.08 8.08 0 0 1 6.66-4.13H47v-35.02a6.1 6.1 0 0 0-3.03-4.87l-.84-.43c-1.59-.8-4-.4-5.24.85l-2.36 2.36A12 12 0 0 1 28 109a13 13 0 1 1 0-26c2.47 0 5.79 1.37 7.53 3.11l2.36 2.36a4.94 4.94 0 0 0 5.24.85l.84-.43A6.1 6.1 0 0 0 47 84.02V49H11.98a8.08 8.08 0 0 1-6.66-4.13l-.43-.84a6.91 6.91 0 0 1 1.22-7.56l2.36-2.36A10.06 10.06 0 0 0 11 28 11 11 0 0 0 0 17v-2a13 13 0 0 1 13 13c0 2.47-1.37 5.79-3.11 7.53l-2.36 2.36a4.94 4.94 0 0 0-.85 5.24l.43.84A6.1 6.1 0 0 0 11.98 47H47V11.98a8.08 8.08 0 0 1 4.13-6.66l.84-.43a6.91 6.91 0 0 1 7.56 1.22l2.36 2.36A10.06 10.06 0 0 0 68 11 11 11 0 0 0 79 0h2a13 13 0 0 1-13 13 12 12 0 0 1-7.53-3.11l-2.36-2.36a4.93 4.93 0 0 0-5.24-.85l-.84.43A6.1 6.1 0 0 0 49 11.98V47h35.02a8.08 8.08 0 0 1 6.66 4.13l.43.84a6.91 6.91 0 0 1-1.22 7.56l-2.36 2.36A10.06 10.06 0 0 0 85 68a11 11 0 0 0 22 0c0-1.94-1.16-4.75-2.53-6.11l-2.36-2.36a6.93 6.93 0 0 1-1.22-7.56l.43-.84a8.08 8.08 0 0 1 6.66-4.13H143V11.98a6.1 6.1 0 0 0-3.03-4.87l-.84-.43c-1.59-.8-4-.4-5.24.85l-2.36 2.36A12 12 0 0 1 124 13a13 13 0 0 1-13-13h2a11 11 0 0 0 11 11c1.94 0 4.75-1.16 6.11-2.53l2.36-2.36a6.93 6.93 0 0 1 7.56-1.22l.84.43a8.08 8.08 0 0 1 4.13 6.66V47h35.02a6.1 6.1 0 0 0 4.87-3.03l.43-.84c.8-1.59.4-4-.85-5.24l-2.36-2.36A12 12 0 0 1 179 28a13 13 0 0 1 13-13zM84.02 143a6.1 6.1 0 0 0 4.87-3.03l.43-.84c.8-1.59.4-4-.85-5.24l-2.36-2.36A12 12 0 0 1 83 124a13 13 0 1 1 26 0c0 2.47-1.37 5.79-3.11 7.53l-2.36 2.36a4.94 4.94 0 0 0-.85 5.24l.43.84a6.1 6.1 0 0 0 4.87 3.03H143v-35.02a8.08 8.08 0 0 1 4.13-6.66l.84-.43a6.91 6.91 0 0 1 7.56 1.22l2.36 2.36A10.06 10.06 0 0 0 164 107a11 11 0 0 0 0-22c-1.94 0-4.75 1.16-6.11 2.53l-2.36 2.36a6.93 6.93 0 0 1-7.56 1.22l-.84-.43a8.08 8.08 0 0 1-4.13-6.66V49h-35.02a6.1 6.1 0 0 0-4.87 3.03l-.43.84c-.79 1.58-.4 4 .85 5.24l2.36 2.36a12.04 12.04 0 0 1 3.11 7.51A13 13 0 1 1 83 68a12 12 0 0 1 3.11-7.53l2.36-2.36a4.93 4.93 0 0 0 .85-5.24l-.43-.84A6.1 6.1 0 0 0 84.02 49H49v35.02a8.08 8.08 0 0 1-4.13 6.66l-.84.43a6.91 6.91 0 0 1-7.56-1.22l-2.36-2.36A10.06 10.06 0 0 0 28 85a11 11 0 0 0 0 22c1.94 0 4.75-1.16 6.11-2.53l2.36-2.36a6.93 6.93 0 0 1 7.56-1.22l.84.43a8.08 8.08 0 0 1 4.13 6.66V143h35.02z'%3E%3C/path%3E%3C/svg%3E");
      }
      &.dark {
        &.patterns {
          background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='192' height='192' viewBox='0 0 192 192'%3E%3Cpath fill='%23fcfcfc' fill-opacity='0.08' d='M192 15v2a11 11 0 0 0-11 11c0 1.94 1.16 4.75 2.53 6.11l2.36 2.36a6.93 6.93 0 0 1 1.22 7.56l-.43.84a8.08 8.08 0 0 1-6.66 4.13H145v35.02a6.1 6.1 0 0 0 3.03 4.87l.84.43c1.58.79 4 .4 5.24-.85l2.36-2.36a12.04 12.04 0 0 1 7.51-3.11 13 13 0 1 1 .02 26 12 12 0 0 1-7.53-3.11l-2.36-2.36a4.93 4.93 0 0 0-5.24-.85l-.84.43a6.1 6.1 0 0 0-3.03 4.87V143h35.02a8.08 8.08 0 0 1 6.66 4.13l.43.84a6.91 6.91 0 0 1-1.22 7.56l-2.36 2.36A10.06 10.06 0 0 0 181 164a11 11 0 0 0 11 11v2a13 13 0 0 1-13-13 12 12 0 0 1 3.11-7.53l2.36-2.36a4.93 4.93 0 0 0 .85-5.24l-.43-.84a6.1 6.1 0 0 0-4.87-3.03H145v35.02a8.08 8.08 0 0 1-4.13 6.66l-.84.43a6.91 6.91 0 0 1-7.56-1.22l-2.36-2.36A10.06 10.06 0 0 0 124 181a11 11 0 0 0-11 11h-2a13 13 0 0 1 13-13c2.47 0 5.79 1.37 7.53 3.11l2.36 2.36a4.94 4.94 0 0 0 5.24.85l.84-.43a6.1 6.1 0 0 0 3.03-4.87V145h-35.02a8.08 8.08 0 0 1-6.66-4.13l-.43-.84a6.91 6.91 0 0 1 1.22-7.56l2.36-2.36A10.06 10.06 0 0 0 107 124a11 11 0 0 0-22 0c0 1.94 1.16 4.75 2.53 6.11l2.36 2.36a6.93 6.93 0 0 1 1.22 7.56l-.43.84a8.08 8.08 0 0 1-6.66 4.13H49v35.02a6.1 6.1 0 0 0 3.03 4.87l.84.43c1.58.79 4 .4 5.24-.85l2.36-2.36a12.04 12.04 0 0 1 7.51-3.11A13 13 0 0 1 81 192h-2a11 11 0 0 0-11-11c-1.94 0-4.75 1.16-6.11 2.53l-2.36 2.36a6.93 6.93 0 0 1-7.56 1.22l-.84-.43a8.08 8.08 0 0 1-4.13-6.66V145H11.98a6.1 6.1 0 0 0-4.87 3.03l-.43.84c-.79 1.58-.4 4 .85 5.24l2.36 2.36a12.04 12.04 0 0 1 3.11 7.51A13 13 0 0 1 0 177v-2a11 11 0 0 0 11-11c0-1.94-1.16-4.75-2.53-6.11l-2.36-2.36a6.93 6.93 0 0 1-1.22-7.56l.43-.84a8.08 8.08 0 0 1 6.66-4.13H47v-35.02a6.1 6.1 0 0 0-3.03-4.87l-.84-.43c-1.59-.8-4-.4-5.24.85l-2.36 2.36A12 12 0 0 1 28 109a13 13 0 1 1 0-26c2.47 0 5.79 1.37 7.53 3.11l2.36 2.36a4.94 4.94 0 0 0 5.24.85l.84-.43A6.1 6.1 0 0 0 47 84.02V49H11.98a8.08 8.08 0 0 1-6.66-4.13l-.43-.84a6.91 6.91 0 0 1 1.22-7.56l2.36-2.36A10.06 10.06 0 0 0 11 28 11 11 0 0 0 0 17v-2a13 13 0 0 1 13 13c0 2.47-1.37 5.79-3.11 7.53l-2.36 2.36a4.94 4.94 0 0 0-.85 5.24l.43.84A6.1 6.1 0 0 0 11.98 47H47V11.98a8.08 8.08 0 0 1 4.13-6.66l.84-.43a6.91 6.91 0 0 1 7.56 1.22l2.36 2.36A10.06 10.06 0 0 0 68 11 11 11 0 0 0 79 0h2a13 13 0 0 1-13 13 12 12 0 0 1-7.53-3.11l-2.36-2.36a4.93 4.93 0 0 0-5.24-.85l-.84.43A6.1 6.1 0 0 0 49 11.98V47h35.02a8.08 8.08 0 0 1 6.66 4.13l.43.84a6.91 6.91 0 0 1-1.22 7.56l-2.36 2.36A10.06 10.06 0 0 0 85 68a11 11 0 0 0 22 0c0-1.94-1.16-4.75-2.53-6.11l-2.36-2.36a6.93 6.93 0 0 1-1.22-7.56l.43-.84a8.08 8.08 0 0 1 6.66-4.13H143V11.98a6.1 6.1 0 0 0-3.03-4.87l-.84-.43c-1.59-.8-4-.4-5.24.85l-2.36 2.36A12 12 0 0 1 124 13a13 13 0 0 1-13-13h2a11 11 0 0 0 11 11c1.94 0 4.75-1.16 6.11-2.53l2.36-2.36a6.93 6.93 0 0 1 7.56-1.22l.84.43a8.08 8.08 0 0 1 4.13 6.66V47h35.02a6.1 6.1 0 0 0 4.87-3.03l.43-.84c.8-1.59.4-4-.85-5.24l-2.36-2.36A12 12 0 0 1 179 28a13 13 0 0 1 13-13zM84.02 143a6.1 6.1 0 0 0 4.87-3.03l.43-.84c.8-1.59.4-4-.85-5.24l-2.36-2.36A12 12 0 0 1 83 124a13 13 0 1 1 26 0c0 2.47-1.37 5.79-3.11 7.53l-2.36 2.36a4.94 4.94 0 0 0-.85 5.24l.43.84a6.1 6.1 0 0 0 4.87 3.03H143v-35.02a8.08 8.08 0 0 1 4.13-6.66l.84-.43a6.91 6.91 0 0 1 7.56 1.22l2.36 2.36A10.06 10.06 0 0 0 164 107a11 11 0 0 0 0-22c-1.94 0-4.75 1.16-6.11 2.53l-2.36 2.36a6.93 6.93 0 0 1-7.56 1.22l-.84-.43a8.08 8.08 0 0 1-4.13-6.66V49h-35.02a6.1 6.1 0 0 0-4.87 3.03l-.43.84c-.79 1.58-.4 4 .85 5.24l2.36 2.36a12.04 12.04 0 0 1 3.11 7.51A13 13 0 1 1 83 68a12 12 0 0 1 3.11-7.53l2.36-2.36a4.93 4.93 0 0 0 .85-5.24l-.43-.84A6.1 6.1 0 0 0 84.02 49H49v35.02a8.08 8.08 0 0 1-4.13 6.66l-.84.43a6.91 6.91 0 0 1-7.56-1.22l-2.36-2.36A10.06 10.06 0 0 0 28 85a11 11 0 0 0 0 22c1.94 0 4.75-1.16 6.11-2.53l2.36-2.36a6.93 6.93 0 0 1 7.56-1.22l.84.43a8.08 8.08 0 0 1 4.13 6.66V143h35.02z'%3E%3C/path%3E%3C/svg%3E");
        }
        .cover {
          filter: brightness(0.6);
        }
      }
      .cover {
        width: auto;
        height: auto;
        min-height: 100%;
        opacity: 0;
        transition:
          filter 0.3s,
          opacity 0.3s;
        &.loaded {
          opacity: 1;
        }
      }
    }
    </style>
    
        <header class="main-header">
            <nav class="main-nav">
                <div class="nav-all">
                    
                    <div class="left-nav">
                        <div class="more-menu nav-btn" title="更多内容">
                            <i class="iconfont icon-menu"></i><div class="more-menu-panel">
    <div class="menu-list">
        
    </div>
</div> </div>
                        <div class="site-name">
                            元视角
                        </div>
                    </div>
                    
                    
                    <div class="nav-center">
                        <div class="site-menu"><div class="menu-list">
    
    <div class="menu-item">
        <span class="link-btn"> 文库</span>
        
    </div>
    
    <div class="menu-item">
        <span class="link-btn"> 书影音</span>
        
    </div>
    
    <div class="menu-item">
        <span class="link-btn"> 友链</span>
        
    </div>
    
    <div class="menu-item">
        <span class="link-btn"> 关于</span>
        
    </div>
    
</div> </div>
                        <span class="site-title">
                            动漫
                        </span>
                    </div>
                    
                    
                    <div class="right-nav">
                        
                        <a class="menu-btn nav-btn travellings" title="开往-友链接力" href="https://www.travellings.cn/go.html" target="_blank">
                            <i class="iconfont icon-subway"></i>
                        </a>
                        
                        <div class="menu-btn nav-btn" title="随机前往一篇文章">
                            <i class="iconfont icon-shuffle"></i>
                        </div>
                        
                        <div class="menu-btn nav-btn" title="全站搜索">
                            <i class="iconfont icon-search"></i>
                        </div>
                        
                        <div id="open-control" class="menu-btn nav-btn pc" title="打开中控台">
                            <i class="iconfont icon-dashboard"></i>
                        </div>
                        
                        <div class="to-top menu-btn" title="返回顶部">
                            <div class="to-top-btn">
                                <span class="num">0</span>
                                <i class="iconfont icon-up"></i>
                            </div>
                        </div>
                        
                        <div class="menu-btn nav-btn mobile" title="打开菜单">
                            <i class="iconfont icon-toc"></i>
                        </div>
                    </div>
                </div>
            </nav>
            <div class="mobile-menu">
    <div class="menu-mask"></div>
    <div class="menu-content">
        <div class="menu-header">
            <div class="site-info">
                <div class="site-name">元视角</div>
                <div class="site-description">纵有疾风起，人生不言弃</div>
            </div>
        </div>
        <div class="menu-body">
            
            <div class="menu-group">
                <div class="menu-title">导航</div>
                <div class="menu-list">
                    
                    
                    <a class="menu-item" href="" >
                        
                        <span>文库</span>
                    </a>
                    
                    <a class="menu-item" href="" >
                        
                        <span>书影音</span>
                    </a>
                    
                    <a class="menu-item" href="" >
                        
                        <span>友链</span>
                    </a>
                    
                    <a class="menu-item" href="" >
                        
                        <span>关于</span>
                    </a>
                    
                </div>
            </div>
            
            <div class="menu-group">
                <div class="menu-title">更多</div>
                <div class="menu-list">
                    
                </div>
            </div>
        </div>
    </div>
</div> <div class="search-panel">
    <div class="search-mask"></div>
    <div class="search-content">
        <div class="search-header">
            <div class="search-input">
                <i class="iconfont icon-search"></i>
                <input type="text" placeholder="搜索文章..." id="searchInput">
            </div>
            <div class="search-close">
                <i class="iconfont icon-close"></i>
            </div>
        </div>
        <div class="search-body">
            <div class="search-empty">
                <i class="iconfont icon-empty"></i>
                <span>暂无搜索结果</span>
            </div>
            <div class="search-result"></div>
        </div>
    </div>
</div>


<script>
    window.searchData = [
        
        {
            "title": "\"Semantic Kernel × MCP：智能体的上下文增强探索\"",
            "content": "\"时光飞逝，转眼间已步入阳春三月，可我却迟迟未曾动笔写下 2025 年的第一篇 AI 博客。不知大家心中作何感想，从年初 DeepSeek 的爆火出圈，到近期 Manus 的刷屏热议，AI 领域的发展可谓是日新月异。例如，DeepSeek R1 的出现，让人们开始接受慢思考，可我们同样注意到，OpenAI 的 Deep Research 选择了一条和 R1 截然不同的路线，模型与智能体之间的界限开始变得模糊。对于这一点，使用过 Cursor Composer 或者 Deep Research 的朋友，相信你们会有更深刻的感悟。有人说，Agent 会成为 2025 年的 AI 主旋律。我不知道大家是否清楚 AutoGPT 与 Manus 的差别，对我个人而言，最重要的事情是在喧嚣过后找到 “值得亲手去做的事情”。所以，今天这篇博客，我想分享一个 “熟悉而陌生” 的东西：MCP，即：模型上下文协议，并尝试将这个协议和 Semantic Kernel 连接起来。\\nMCP 介绍 [TL;DR] MCP 是由 Anthropic 设计的开放协议，其定位类似于 AI 领域的 USB 接口，旨在通过统一接口解决大模型连接不同数据源和工具的问题。该协议通过 JSON-RPC 规范定义了 Prompt 管理、资源访问和工具调用三大核心能力，使得任何支持 Function Calling 的模型都能无缝对接外部系统，从而帮助大语言模型实现 “万物互联”。\\n什么是 MCP? MCP（Model Context Protocol）是由 Anthropic 设计的一种开放协议，旨在标准化应用程序向大语言模型（LLMs）提供上下文的方式，使大模型能够以统一的方法连接各种数据源和工具。你可以将其理解为 AI 应用的 USB 接口，为 AI 模型连接到不同的数据源和工具提供了标准化的方法。架构设计上，MCP 采用了经典的 C/S 架构，客户端可以使用该协议灵活地连接多个 MCP Server，从而获取丰富的数据和功能支持，如下图所示：\\n具体而言，MCP 架构中包括四个核心角色：\\nMCP Host：承载用户交互的终端，如 Claude Desktop、Cusror、VSCode 等，负责发起请求 MCP Client：协议客户端，负责建立、维护与服务器端的一对一连接，通常需要集成 SDK 到 MCP Host MCP Server: 协议服务器端，对外暴露三种核心能力：Prompts、Resources 和 Tools Data Source：数据源，是本地资源（如 SQLite、文件系统）与远程服务（如 Github API）的集合 为什么选择 MCP? 在过去的这一年里，AI 智能体的技术生态逐渐呈现出两种典型的演进方向。首先，是以 LangChain、Semantic Kernel 等为代表的 AI 框架；其次，是以 Dify、Coze 等为代表的智能体编排平台。这实际上揭示了当前智能体技术发展的双重路径，即：人们正试图从框架层和平台层两个维度去攻克 Agent 技术的高峰。\\n然而，当你真正地深入实践这一切的时候，你会在这些框架和平台中发现许多痛点。例如：\\n语言框架的割裂性：不同技术栈中对 Agent 基础元素的定义存在着根本性差异。例如，LangChain 中采用 Python 的 @tool 装饰器来标注工具方法，而 C# 系列的 Semantic Kernel 则通过 [KernelFunction] 特性来实现功能注册。这种语法层面的分歧，无形中增加了跨平台协作的成本。 平台生态的封闭性：以 Coze 和 Dify 的插件系统为例，虽然二者均支持集成 Jina AI 插件，但是其工作流编排和配置的规范完全不同。这种生态壁垒加剧了不同技术体系间的 “数字鸿沟”，造成应用迁移成本过高，最终导致智能体平台沦为信息孤岛。 开发资源的重复消耗：目前，无论是服务供应商还是开发者，均需要参与智能体平台的适配工作，容易造成重复性工作，这对于 AI 时代而言是一种注意力的浪费。更重要是，这不利于 AI 技术的进一步发展，真正具有突破性的技术创新难以获得足够关注。 如你所见，有了 MCP 以后，开发人员只需要和 MCP 打交道，这是真正意义上的 “Attention Is All You Need”。\\nMCP 如何工作? 现在，当我们将目光聚焦在 MCP 上面时，我们会发现情况开始有所好转，因为 Anthropic 使用 JSON-RPC 规范定义了一套与语言、平台无关的协议。在该协议中，定义了 Requests、Responses 和 Notifications 三种消息类型：\\nType Description Requirements Requests Messages sent to initiate an operation Must include unique ID and method name Responses Messages sent in reply to requests Must include same ID as request Notifications One-way messages with no reply Must not include an ID 在上文中我们提到，MCP 支持 Prompts、Resources 和 Tools 三大核心能力。以 Tools 这个最常见的能力为例，MCP 支持工具的发现、调用和更新，其交互过程通常如下图所示：\\n此时，我们会注意到，MCP 针对工具调用主要提供了三个 API：tools/list、tools/call 以及 notifications/tools/list_changed。其中，notifications/tools/list_changed 是可选的，属于 Notification 的一部分。顾名思义，当服务器端提供的工具列表发生变化时，它能够以通知的形式告知客户端这一变化。如果你熟悉 JSON-RPC 规范，相信你已经在脑海中推测出具体的消息结构。首先，客户端通过 tools/list 方法向服务器端发起请求：\\n{ \\u0026#34;jsonrpc\\u0026#34;: \\u0026#34;2.0\\u0026#34;, \\u0026#34;id\\u0026#34;: 1, \\u0026#34;method\\u0026#34;: \\u0026#34;tools/list\\u0026#34;, \\u0026#34;params\\u0026#34;: { \\u0026#34;cursor\\u0026#34;: \\u0026#34;optional-cursor-value\\u0026#34; } } 接下来，服务器端会返回它目前支持的工具列表。这里，我们以经典的 get_weather 方法为例：\\n{ \\u0026#34;jsonrpc\\u0026#34;: \\u0026#34;2.0\\u0026#34;, \\u0026#34;id\\u0026#34;: 1, \\u0026#34;result\\u0026#34;: { \\u0026#34;tools\\u0026#34;: [{ \\u0026#34;name\\u0026#34;: \\u0026#34;get_weather\\u0026#34;, \\u0026#34;description\\u0026#34;: \\u0026#34;get current weather information for a location\\u0026#34;, \\u0026#34;inputSchema\\u0026#34;: { \\u0026#34;type\\u0026#34;: \\u0026#34;object\\u0026#34;, \\u0026#34;properties\\u0026#34;: { \\u0026#34;location\\u0026#34;: { \\u0026#34;type\\u0026#34;: \\u0026#34;string\\u0026#34;, \\u0026#34;description\\u0026#34;: \\u0026#34;city name or zip code\\u0026#34; } }, \\u0026#34;required\\u0026#34;: [\\u0026#34;location\\u0026#34;] } }], \\u0026#34;nextCursor\\u0026#34;: \\u0026#34;next-page-cursor\\u0026#34; } } 如果你接触过 ReAct、Tool Use、Function Calling 这些概念，你会发现这一切是如此地熟悉和亲切。当我们将这些工具提供给 LLM 以后，由 LLM 决定是否要调用指定的工具。此时，我们可以通过 tools/call 方法来调用指定的工具。这里，同样以经典的 get_weather 方法为例：\\n{ \\u0026#34;jsonrpc\\u0026#34;: \\u0026#34;2.0\\u0026#34;, \\u0026#34;id\\u0026#34;: 2, \\u0026#34;method\\u0026#34;: \\u0026#34;tools/call\\u0026#34;, \\u0026#34;params\\u0026#34;: { \\u0026#34;name\\u0026#34;: \\u0026#34;get_weather\\u0026#34;, \\u0026#34;arguments\\u0026#34;: { \\u0026#34;location\\u0026#34;: \\u0026#34;New York\\u0026#34; } } } 此时，我们会收到服务器端的响应消息，如下所示：\\n{ \\u0026#34;jsonrpc\\u0026#34;: \\u0026#34;2.0\\u0026#34;, \\u0026#34;id\\u0026#34;: 2, \\u0026#34;result\\u0026#34;: { \\u0026#34;content\\u0026#34;: [ { \\u0026#34;type\\u0026#34;: \\u0026#34;text\\u0026#34;, \\u0026#34;text\\u0026#34;: \\u0026#34;Current weather in New York:\\\\nTemperature: 72°F\\\\nConditions: Partly cloudy\\u0026#34; } ], \\u0026#34;isError\\u0026#34;: false } } 读到这里，诸位看官心里一定在吐槽：有没有搞错，就这？这好像和 Function Calling 没什么区别嘛！我的理解是，MCP、Function Calling 和 Agent 本质上是一个层层递进的关系，MCP 提供一种与模型、语言、框架无关的工具抽象，任何支持 Function Calling 的模型都可以调用这些工具，而 Agent 框架则在此基础上对工具进行规划与编排。\\n例如，去年年底的时候，Anthropic 和智谱相继发布了 Cumputer Use 功能，可这些功能大多都仅限于在厂商自家的产品中使用。如果你想在国内的 DeekSeek 或者 Kimi 上面尝试，基本上是痴心妄想。可有了 MCP 以后，情况就大不相同。你只需要使用 Playwright MCP Server 或者 Browser-Use MCP Server 便可以轻松 “尝鲜”。这次 Manus 爆火后，社区在几个小时内迅速复刻出了OpenManus，这与该团队直接使用第三方库 browser-use 息息相关。由此可见，一个健康、开放的 AI 生态会极大地促进 AI 应用的繁荣。事实上，自去年 MCP 发布以来，社区里涌现出了大量的第三方 MCP 服务器，这些服务器极大地扩展了 AI 的能力边界。现在，AI 可以连接到 Notion、Slack、Github、Elasticsearch 等众多平台，如下图所示，mcpservers.org、mcp.so 等网站收录了许多 MCP Server：\\n所以，我们为什么要了解 MCP 呢？因为只要接入了 MCP， 便可以拥抱 MCP 背后的整个生态，这意味着 AI 领域的 “万物互联” 时刻已悄然到来。唯一的问题在于，国内外的 AI 厂商是否有意愿一起将 MCP 发展为行业标准。我想，届时无论是服务供应商还是个人开发者，都能从 MCP 这个协议中受益。除了 Tools，MCP 还支持 Resources 和 Prompts 相关的功能，它们负责对提示词、文件等进行管理。当然，这些并不是本文关注的重点，这里不再赘述。我们只需要知道一件事情，对一个 MCP Server 而言，最重要的是实现 tools/list 和 tools/call 这两个方法。目前，官方 SDK 支持 Python、TypeScript、Java 和 Kotlin 这四种语言，我们可以使用这些 SDK 来集成或者开发一个 MCP Server。下面是一个 Python 版本的 SQLite Explorer 示例：\\nfrom mcp.server.fastmcp import FastMCP import sqlite3 mcp = FastMCP(\\u0026#34;SQLite Explorer\\u0026#34;) @mcp.resource(\\u0026#34;schema://main\\u0026#34;) def get_schema() -\\u0026gt; str: \\u0026#34;\\u0026#34;\\u0026#34;Provide the database schema as a resource\\u0026#34;\\u0026#34;\\u0026#34; conn = sqlite3.connect(\\u0026#34;database.db\\u0026#34;) schema = conn.execute( \\u0026#34;SELECT sql FROM sqlite_master WHERE type=\\u0026#39;table\\u0026#39;\\u0026#34; ).fetchall() return \\u0026#34;\\\\n\\u0026#34;.join(sql[0] for sql in schema if sql[0]) @mcp.tool() def query_data(sql: str) -\\u0026gt; str: \\u0026#34;\\u0026#34;\\u0026#34;Execute SQL queries safely\\u0026#34;\\u0026#34;\\u0026#34; conn = sqlite3.connect(\\u0026#34;database.db\\u0026#34;) try: result = conn.execute(sql).fetchall() return \\u0026#34;\\\\n\\u0026#34;.join(str(row) for row in result) except Exception as e: return f\\u0026#34;Error: {str(e)}\\u0026#34; 如你所见，在该示例中，MCP Server 提供了一个 resource、一个 tool，前者负责返回当前数据库中的 DDL，后者提供一个查询数据的方法。恭喜你，现在你可以开始着手设计一个针对 Text2SQL 的 Agent 了。\\nMCP 的局限性 当然，我们需要学会辩证地看待事物，MCP 并非完美无瑕。首先，我们不清楚国内外厂商适配这一协议的热情到底有多少；其次，类似于大多数 AI 框架，MCP 正处在迅速发展阶段，该协议的最新版本是 2024-11-05。截止目前，官方在 2025 年上半年的 Roadmap 主要集中在：认证/授权、服务发现、无状态操作。所以，未来走向到底如何，着实充满了变数。例如，按照官方的设计，MCP 在传输层（Transports）支持 stdio 和 HTTP with Server-Sent Events (SSE)，可目前大多数的 MCP Server 都是运行在本地的 stdio。对于终端用户而言，使用 MCP 依然需要了解 Python、Node.js 甚至 Docker，不得不说，这其实是一种隐形的成本。\\nSemantic Kernel x MCP 在 Semantic Kernel 中，我们使用插件（Plugin）这个概念来描述一组工具，而每个工具则是一个 KernelFunction。因此，如果希望在 Semantic Kernel 中集成 MCP，本质上就是将 MCP 中的 Tools 转换为 Semantic Kernel 中的 KernelFunction。如上图所示，我们将在 Semantic Kernel 中集成一个 MCP 客户端，然后利用 tools/list 和 tools/call 这两个 API 分别实现工具获取、工具调用这两个流程。\\n工具获取 截止目前，MCP 官方还没有提供对 .NET 的支持，不过社区里还是出现了第三方实现。例如：\\nMCPSharp: https://github.com/afrise/MCPSharp mcpdotnet: https://github.com/PederHP/mcpdotnet 博主这里选择的是 mcpdotnet，假设我们希望在 Semantic Kernel 中集成 Playwright MCP Server。此时，我们可以编写下面的代码来连接到对应的 MCP Server：\\nvar clientOptions = new McpClientOptions() { ClientInfo = new McpDotNet.Protocol.Types.Implementation() { Name = name, Version = \\u0026#34;1.0.0\\u0026#34; }, }; var serverConfig = new McpServerConfig() { Id = \\u0026#34;playwright\\u0026#34;, Name = \\u0026#34;playwright\\u0026#34;, TransportType = \\u0026#34;stdio\\u0026#34;, TransportOptions = new Dictionary\\u0026lt;string, string\\u0026gt; { [\\u0026#34;command\\u0026#34;] = \\u0026#34;npx\\u0026#34;, [\\u0026#34;arguments\\u0026#34;] = \\u0026#34;-y @executeautomation/playwright-mcp-server\\u0026#34;, } }; var loggerFactory = kernel.Services.GetRequiredService\\u0026lt;ILoggerFactory\\u0026gt;(); var clientFactory = new McpClientFactory( [serverConfig], clientOptions, NullLoggerFactory.Instance ); var client = await clientFactory.GetClientAsync(serverConfig.Id).ConfigureAwait(false); 从 clientFactory 获取 IMcpClient 实例时，客户端会先调用 initialize() 方法。服务器端初始化完成后，会给客户端发送 notifications/initialized 通知，表明服务器端已完成初始化。此时，可调用 ListToolsAsync() 方法，获取 MCP 服务器端提供的工具列表:\\nvar listToolsResult = await client.ListToolsAsync().ConfigureAwait(false); var tools = listToolsResult.Tools; 协议转换 从前文中可知，MCP 使用 JSONSchema 来描述工具的输入参数，返回值则被定义为一个数组，如下图所示：\\n因此，我们需要写一个中间层，将 MCP 的工具转换为 KernelFunction，这部分内容非常简单，不再赘述：\\n// 将 MCP 中的 Tool 转换为 KernelFunction private static KernelFunction ToKernelFunction(this Tool tool, IMcpClient client) { async Task\\u0026lt;string\\u0026gt; InvokeToolAsync( Kernel kernel, KernelFunction function, KernelArguments arguments, CancellationToken cancellationToken ) { try { var mcpArguments = new Dictionary\\u0026lt;string, object\\u0026gt;(); foreach (var arg in arguments) { if (arg.Value is not null) mcpArguments[arg.Key] = function.ToArgumentValue(arg.Key, arg.Value); } var result = await client.CallToolAsync( tool.Name, mcpArguments, cancellationToken: cancellationToken ).ConfigureAwait(false); return string.Join(\\u0026#34;\\\\n\\u0026#34;, result.Content .Where(c =\\u0026gt; c.Type == \\u0026#34;text\\u0026#34;) .Select(c =\\u0026gt; c.Text)); } catch { throw; } } return KernelFunctionFactory.CreateFromMethod( method: InvokeToolAsync, functionName: tool.Name, description: tool.Description, parameters: ToKernelParameters(tool), returnParameter: ToKernelReturnParameter() ); } // 将 MCP 中工具的输入转换为 KernelFunction 输入 private static List\\u0026lt;KernelParameterMetadata\\u0026gt; ToKernelParameters(Tool tool) { var inputSchema = tool.InputSchema; var properties = inputSchema?.Properties; if (properties == null) return []; HashSet\\u0026lt;string\\u0026gt; requiredProperties = new(inputSchema!.Required ?? []); return properties.Select(kvp =\\u0026gt; new KernelParameterMetadata(kvp.Key) { Description = kvp.Value.Description, ParameterType = ConvertParameterDataType(kvp.Value, requiredProperties.Contains(kvp.Key)), IsRequired = requiredProperties.Contains(kvp.Key) }) .ToList(); } // 将 JSONSchema 中的数据类型转换为 C# 的数据类型 private static Type ConvertParameterDataType(JsonSchemaProperty property, bool required) { var type = property.Type switch { \\u0026#34;string\\u0026#34; =\\u0026gt; typeof(string), \\u0026#34;integer\\u0026#34; =\\u0026gt; typeof(int), \\u0026#34;number\\u0026#34; =\\u0026gt; typeof(double), \\u0026#34;boolean\\u0026#34; =\\u0026gt; typeof(bool), \\u0026#34;array\\u0026#34; =\\u0026gt; typeof(List\\u0026lt;string\\u0026gt;), \\u0026#34;object\\u0026#34; =\\u0026gt; typeof(Dictionary\\u0026lt;string, object\\u0026gt;), _ =\\u0026gt; typeof(object) }; return !required \\u0026amp;\\u0026amp; type.IsValueType ? typeof(Nullable\\u0026lt;\\u0026gt;).MakeGenericType(type) : type; } // 转换返回值，简化处理，直接返回字符串类型 private static KernelReturnParameterMetadata? ToKernelReturnParameter() { return new KernelReturnParameterMetadata() { ParameterType = typeof(string), }; } // 将 KernelFunction 参数转换为 object private static object ToArgumentValue(this KernelFunction function, string name, object value) { var parameter = function.Metadata.Parameters.FirstOrDefault(p =\\u0026gt; p.Name == name); return parameter?.ParameterType switch { Type t when Nullable.GetUnderlyingType(t) == typeof(int) =\\u0026gt; Convert.ToInt32(value), Type t when Nullable.GetUnderlyingType(t) == typeof(double) =\\u0026gt; Convert.ToDouble(value), Type t when Nullable.GetUnderlyingType(t) == typeof(bool) =\\u0026gt; Convert.ToBoolean(value), Type t when t == typeof(List\\u0026lt;string\\u0026gt;) =\\u0026gt; (value as IEnumerable\\u0026lt;object\\u0026gt;)?.ToList(), Type t when t == typeof(Dictionary\\u0026lt;string, object\\u0026gt;) =\\u0026gt; (value as Dictionary\\u0026lt;string, object\\u0026gt;)?.ToDictionary(kvp =\\u0026gt; kvp.Key, kvp =\\u0026gt; kvp.Value), _ =\\u0026gt; value, } ?? value; } 现在，一切就变得简单了，我们可以封装一个如下的扩展方法：\\npublic static async Task\\u0026lt;IEnumerable\\u0026lt;KernelFunction\\u0026gt;\\u0026gt; GetKernelFunctionsAsync(this IMcpClient client) { var listToolsResult = await client.ListToolsAsync().ConfigureAwait(false); return listToolsResult.Tools.Select(tool =\\u0026gt; ToKernelFunction(tool, client)).ToList(); } 工具调用 在 MCP 中，客户端调用服务器端提供的工具，可以直接使用 CallToolAsync() 方法：\\nvar result = await client.CallToolAsync( tool.Name, mcpArguments, cancellationToken: cancellationToken ).ConfigureAwait(false); 当我们转换为 KernelFunction 以后，只需要调用 InvokeAsync() 方法即可调用对应的插件函数。考虑到，在 Agent 中，插件函数通常是由 LLM 来调用的，我们将编写下面的扩展方法来实现工具的注册：\\n// 注册 MCP Server public static async Task AddMCPServer( this Kernel kernel, string name, string command, string version = \\u0026#34;1.0.0\\u0026#34;, string[] args = null, Dictionary\\u0026lt;string, string\\u0026gt; env = null ) { var clientOptions = new McpClientOptions() { ClientInfo = new McpDotNet.Protocol.Types.Implementation() { Name = name, Version = \\u0026#34;1.0.0\\u0026#34; }, }; var serverConfig = new McpServerConfig() { Id = name, Name = name, TransportType = \\u0026#34;stdio\\u0026#34;, TransportOptions = new Dictionary\\u0026lt;string, string\\u0026gt; { [\\u0026#34;command\\u0026#34;] = command, [\\u0026#34;arguments\\u0026#34;] = string.Join(\\u0026#39; \\u0026#39;, args ?? []), } }; var loggerFactory = kernel.Services.GetRequiredService\\u0026lt;ILoggerFactory\\u0026gt;(); var clientFactory = new McpClientFactory([serverConfig], clientOptions, loggerFactory); var client = await clientFactory.GetClientAsync(serverConfig.Id).ConfigureAwait(false); var kernelFunctions = await client.GetKernelFunctionsAsync(); kernel.Plugins.AddFromFunctions(name, kernelFunctions); } 至此，我们便完成了 MCP 在 Semantic Kernel 中的集成。现在，你只需要使用下面的代码片段即可：\\n// 添加 playwright-mcp-server await kernel.AddMCPServer( name: \\u0026#34;playwright\\u0026#34;, command: \\u0026#34;npx\\u0026#34;, version: \\u0026#34;1.0.0\\u0026#34;, args: [\\u0026#34;-y\\u0026#34;, \\u0026#34;@executeautomation/playwright-mcp-server\\u0026#34;], env: null ); 场景化效果展示 好的，当我们给 Semantic Kernel 集成 MCP 以后，现在我们来一起看看它具体能帮我们做什么事情？\\n操作浏览器 如图所示，用户请求：打开 Bing 主页，搜索 \\u0026ldquo;Model Context Protocol\\u0026rdquo;\\n访问文件系统 如图所示，用户请求：我在 D:\\\\Projects\\\\2024 这个 Git 仓库中都提交过那些代码，最近的一次的更新是什么？\\n读取 Github 仓库 如图所示，用户请求：阅读 OpenManus 仓库的代码，帮我分析其架构、设计相关的细节\\n博主先后体验了四个 MCP Server。其中，Knowledge Graph Memory Server 可以在本地构建知识图谱，从对话中提取并持久化三元组，实现长期记忆。当然，这里的关键在于，确定三元组的读写时机。今年，我准备将现有 RAG 和 Agent 融合，升级为 Agentic RAG。目前，考虑的是将 ReAct 模式应用于 RAG，显然，这里同样会遇到一个问题，即： LLM 如何判定上下文足以生成最终答案。因篇幅限制，此处不再展示更多截图，一切都需要大家去亲自体验。\\n本文小结 MCP 是 Anthropic 设计的开放协议，其定位类似于 AI 领域的 USB 接口，希望通过统一接口解决大模型连接不同数据源和工具的问题。Semantic Kernel 是微软开源的 Agent 框架，两者的结合可以让 .NET 开发者快速、高效地接入社区中的 MCP 服务器，减少重复性的平台对接工作。除工具调用外，还可以考虑将项目中的提示词模板统一放置到 MCP Server 上管理。博主撰写此文时，网络正在传播着被破解的 Manus 源代码。虽然经常有人说提示工程已不存在了，可在实际的项目中提示词依旧不可或缺。从这个角度来看，尽管提示词技术含量不高，但若能得到妥善管理，至少会比项目被破解、提示词被泄露更显体面。关于更多 MCP 的细节，请参考官方文档：Introduction - Model Context Protocol ，无论你是开发者还是普通用户，相信都能在那里找到答案。\\n参考链接 Model Context Protocol Model Context Protocol Specification LLM Function-Calling vs. Model Context Protocol (MCP) Integrating Model Context Protocol Tools with Semantic Kernel: A Step-by-Step Guide 什么是模型上下文协议（MCP）？它如何比传统API更简单地集成AI？ \"",
            "url": "\"/posts/semantic-kernel-mcp-agent-context-enhanced-exploration/\"",
            "date": "\"2025-03-09\""
        },
        
        {
            "title": "\"命运、偏见与自由：《魔童之哪吒闹海》的终极抗争\"",
            "content": "\"在金庸先生的《射雕英雄传》中，有一个情节令人难以忘怀。一向被视为离经叛道的“东邪”黄药师，在得知女儿黄蓉对郭靖情根深种时，亦不免喟然长叹：“且夫天地为炉兮，造化为工；阴阳为炭兮，万物为铜”。贾谊的郁郁而终，靖蓉的长岭遇雨，在遥远的历史的长河中千回百转，可谓“不谋而遐迩自同”。或许，无论是事业与爱情，其底色都难免带着些许苦涩，否则，天地何以成为熔炉，让万物在其中备受煎熬。当然，今天我想聊的不是金庸，而是春节档票房冠军《哪吒之魔童闹海》。这部改编自中国古代神话的动画电影，融合传统神话与现代叙事，在冰与火交织的冲突下，在大银幕上演绎了一部普罗米修斯式的抗争史，带给观众一场视觉与心灵的双重震撼。\\n从身份认同到体系反思 如果说，《哪吒》系列第一部《魔童降世》的核心冲突源于身份认同，那么，这一次《魔童闹海》开始将视野拓展至对体系与秩序的思考。帕拉图曾提出“人生三问”——我是谁？我从哪里来？我要到哪里去？哪吒曾为“魔丸”和“灵珠”的身份困扰，然而，在其父母的影响下，他坚定地喊出：“我命由我不由天”，是魔是仙要由自己说了算，表达对命运的不屈抗争。他完全不在意世俗的眼光，毅然决然地等待天雷落下。如果用一句话概括：“若命运不公，就和它斗到底”，我个人认为，这句话是《哪吒》系列最好的注脚。剧情上，这部作品与前作一脉相承，哪吒和敖丙在天劫中大难不死，虽然肉身毁灭，可魂魄得以在七色宝莲中保全。当然，这一切的代价是太乙真人被夺去顶上三花。\\n因此，第二部的故事便围绕着“劫后余生”展开。因为哪吒和敖丙的肉身损坏，所以，太乙真人借助七色宝莲和藕粉为二人重塑身体。然而，此时申公豹借四海龙王之力，引海底妖族攻入陈塘关。敖丙为护陈塘关擅自移动身体，导致塑造的肉身再次损坏。适逢七色宝莲灵力枯竭，为了得到能让七色宝莲再次盛开的玉液琼浆，哪吒和敖丙被迫共用一个身体，前往昆仑山玉虚宫升仙考核。这种剧情上的转折、递进，节奏紧凑，扣人心弦，可以说是全程无尿点。重塑身体与升仙考核两大情节，贡献了整部电影的大部分的笑点，特别是哪吒塑型这一步，简直就是现实中甲方乙方的真实写照。影片中中真正深刻的东西，我认为，直到陈塘关被屠城这一刻才开始逐渐呈现出来。\\n命运熔炉中的权力游戏 教员有首词叫做《贺新郎·读史》，其中有一句“铜铁炉中翻火焰，为问何时猜得”。众所周知，铜器时代和铁器时代是人类历史上的两个重要阶段，它们标志着人类在金属加工技术、社会结构和文明进步方面的巨大飞跃。结合第一部的剧情，哪吒的宿命，原本就开始于一场精心设计的“冶金游戏”，元始天尊将混元珠投入天元鼎，试图在一个相生相克的世界中提炼出永恒秩序。自此，被标记为“魔丸”的哪吒一生下来，便承受着世俗偏见带来“先天原罪”。如申公豹所言，“人心中的成见是一座大山”。龙族接受天庭“招安”，负责为其镇压海底妖兽，可这处名为“龙宫”的所在，又何尝不是关押龙族的“地牢”呢？因此，敖丙从一出生就被赋予了振兴龙族的使命，那件万龙甲便是最好的证明。\\n电影中的偏见不止于此，当两只结界兽赶到玉虚宫报信时，有多少人想当然地认为，是申公豹屠戮了陈塘关的百姓呢？这同样是一种偏见。如果说，土坡鼠、申正道和石矶娘娘这三道试题，只是让你隐隐对阐教的正义性产生了一丝怀疑。那么，当巨大的天元鼎垂直插入东海海底的时候，你是否从无量仙翁那张道貌岸然的脸上，读出了某种献祭的意味呢？因为妖族修行比人类更勤勉，哪怕它们没做过坏事；因为龙族是实力强大的妖族，哪怕它们早已归顺；因为要嫁祸龙族而大举屠城，哪怕陈塘关的百姓无辜冤死。《贺新郎》里写道：“人世难逢开口笑，上疆场彼此弯弓月。流遍了，郊原血”。回顾历史，宏大叙事下的“电车难题”持续上演，十字军东征时的“上帝旨意”、殖民主义者的“文明开化”……，无一不是在用别人的血肉浇筑“封神”的圣坛。《封神演义》中阐截二教，到底孰是孰非呢？\\n自由与秩序的永恒斗争 诚然，电影依旧没能突破束缚，即：“高层隐身、中层搞事、底层遭殃”的叙事套路，甚至我们无从得知，无量仙翁的行为，到底是私心作祟下的自作主张，还是元始天尊的暗中授意。可这种“个体失范代替制度失范”的切入点，还是能给观众带来某种思考：从来如此，便对吗？善与恶，是魔是仙，从来都不应该由种族和身份决定，申公豹有自己的坚守与珍视，阐教有在封神大战前壮大实力的私心，敖光有保护龙族而委曲求全的无奈，在体系框架内循规蹈矩固然重要，可当个体困境变成群体困境、退无可退的时候，或许，跳出陈规、尝试打破规则，一切自然会柳暗花明、迎来转机。当哪吒的肉身在三昧真火中完成重塑、当人族和妖族齐心协力打破天元鼎的桎梏、当定海神针在落日下缓缓浮出海面……我想，哪吒撕裂的或许是人类文明进程中的永恒困境：在命运熔炉的烈焰中，我们到底是等待煅烧的铜铁，还是执掌锤柄的工匠？“怀璧其罪”、“欲加之罪”，本质上都是一种群体对个体道德上的绑架和霸凌。\\n古希腊哲人赫拉克利特曾说过：“世界是一团永恒的活火”。而哪吒的选择则昭示着：与其在烈焰中化为灰烬，不如让火焰成为涅槃的锤砧。我们无需过渡解读，说昆仑山的玉虚宫像白宫、天元鼎上的符文像美元、成仙的玉牌像绿卡、压住丹炉的像棵摇钱树，甚至无量仙翁、鹿童、鹤童比妖怪更像妖怪……当哪吒与敖丙联手击败无量仙翁，一切的建筑都灰飞烟灭，那个定义神仙妖魔的符号体系，更是被彻底解构、直至崩塌。在这部电影中，所有的海底妖兽都被用锁链束缚在定海神针上面。或许，只需阐教的一道咒语，便能解开这些枷锁。可要解开人心的锁链，显然要艰难百倍。对哪吒而言，是不再纠结于魔丸的身份；对敖丙而言，是不再背负振兴家族的使命。加缪在《反抗者》中写道：“我反抗，故我们存在”。影片最后，妖族与阐教的决战，难道不比《复仇者联盟》更燃？我相信，如果贾谊看过这部电影，一定不会如此草率地写下“天地为炉”。因为在自由面前，秩序终将被反抗者打破。\\n\"",
            "url": "\"/posts/ne-zha-2/\"",
            "date": "\"2025-02-06\""
        },
        
        {
            "title": "\"基于 K-Means 聚类分析实现人脸照片的快速分类\"",
            "content": "\" 注：本文在创作过程中得到了 ChatGPT、DeepSeek、Kimi 的智能辅助支持，由作者本人完成最终审阅。\\n在 “视频是不能 P 的” 系列文章中，博主曾先后分享过人脸检测、人脸识别等相关主题的内容。今天，博主想和大家讨论的是人脸分类问题。你是否曾在人群中认错人，或是盯着熟人的照片却一时想不出对方的名字？这种 “脸盲症” 的困扰，不仅在生活中令人感到尴尬，在整理照片时更是让人头疼不已。想象一下，某次聚会结束后，你的手机里存了上百张照片——有你的笑脸、朋友的自拍，甚至还有一部分陌生面孔混杂其中。手动将这些照片按人物分类，不仅费时费力，还可能会因为 “脸盲” 而频繁出错。此时，你是否期待有一种技术，可以像魔法一样，自动将这些照片按人物分类？事实上，这种 “魔法” 已经存在，它的名字叫做 K-Means 聚类分析。作为一种经典的无监督学习算法，K-Means 能够通过分析人脸特征，自动将相似的面孔归类到一起，完全无需人工干预。接下来，为了彻底根治 “脸盲症”，我们将详细介绍如何使用 K-Means 聚类分析来实现这一目标，哈利·波特拥有魔法，而我们则拥有科技。\\n实现过程 如图所示，我们将按照下面的流程来达成 “自动分类人脸” 这一目标。其中，Dlib 负责提取人脸特征向量、Scikit-Learn 中的 K-Means 负责聚类分析、Matplotlib 负责结果的可视化：\\nK-Means 简介 K-Means 是一种广泛应用的聚类算法，其基本原理是将数据集分成 K 个簇，目标是让每个簇内的数据点尽可能相似，而不同簇之间的数据点尽可能差异明显。K-Means 的执行过程如下：\\n随机选取 K 个初始中心点。\\n将每个数据点分配到距离最近的中心点所对应的簇。\\n更新每个簇的中心点，通常取簇内所有数据点的均值。\\n重复步骤 2 和 3，直到中心点不再发生变化或达到预设的最大迭代次数。\\n如下图所示，图中展示了四种不同的聚类数据分布情况，按照从左到右、自上而下的顺序：\\n图一：簇划分不正确或者簇数量假设错误 图二：数据分布具有各向异性，簇的形状是一个拉长的椭圆形，而不是对称的圆形 图三：各个簇之间的方差不同，绿色簇分布更紧密，而黄色簇分布更稀疏 图四：簇的大小不均匀，黄色簇数据点较少，而紫色簇数据点较多 因此，适用于 K-Means 的数据通常满足：\\n簇是球状且分布均匀 簇的大小相近 簇无明显噪声点或者离群点 数据是各向同性分布 簇的数量已知 数据维度适中 如何确定 K 值 在使用 K-Means 之前，我们需要确定 K 值，即簇的数量。下面是三种常用的确定 K 值的方法：\\n肘部法则/手肘图法（Elbow Method）：通过计算不同 K 值下的聚类误差平方和（SSE, Sum of Squared Errors），找到误差下降速度明显减缓的 “拐点”，这个拐点对应的 K 值即为最佳聚类数。 轮廓系数法（Silhouette Coefficient）：通过计算每个数据点的轮廓系数，评估聚类效果，选择轮廓系数最大的 K 值。轮廓系数结合了聚类的紧密度(同一簇内样本的相似度)和分离度(不同簇之间的差异度)。 戴维斯-博尔丁评分（Davies-Bouldin Index）：通过计算每个簇的簇内距离（样本到簇中心的平均距离）与簇间距离（不同簇中心之间的距离）的比值，评估聚类效果，选择评分最低的 K 值。 如图所示，分别展示了不同方法下的最佳 K 值，综合考虑三种评估方案，此处取 K=6：\\n提取人脸特征 为了对人脸照片进行聚类，我们首先需要提取人脸特征。为此，我们使用 Dlib 库，它提供了一个基于深度学习的预训练模型，该模型能够高效地将人脸图像转换为 128 维的特征向量。\\nimport dlib import cv2 import numpy as np # 加载人脸检测器和特征提取器 detector = dlib.get_frontal_face_detector() predictor = dlib.shape_predictor(\\u0026#34;./models/shape_predictor_68_face_landmarks.dat\\u0026#34;) face_model = dlib.face_recognition_model_v1(\\u0026#34;./models/dlib_face_recognition_resnet_model_v1.dat\\u0026#34;) # 提取人脸特征 def extract_face_features(image_path): img = cv2.imread(image_path) gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) faces = detector(gray) if not faces: return None max_face = max(faces, key=lambda rect: rect.width() * rect.height()) shape = predictor(gray, max_face) feature = face_model.compute_face_descriptor(img, shape) return np.array(feature) K-Means 聚类 接下来，在提取了人脸特征值后，我们可以使用 Scikit-Learn 中的 K-Means 方法进行聚类:\\nfrom sklearn.cluster import KMeans X, image_paths = load_dataset(dataset_path) scaler = StandardScaler() X = scaler.fit_transform(X) # 使用 K-means 进行聚类 num_clusters = 6 kmeans = KMeans(n_clusters=num_clusters, n_init=50, random_state=42, init=\\u0026#39;k-means++\\u0026#39;) kmeans.fit(X) # 获取聚类标签 labels = kmeans.labels_ 其中，load_dataset() 方法用于返回特征值和图片路径，因为最终我们需要将这些图片移动到不同的文件夹中，以实现图片分类。下面是该方法的具体实现：\\ndef load_dataset(dataset_path): results = [ (features, image_path) for image_name in os.listdir(dataset_path) if (image_path := os.path.join(dataset_path, image_name)) and (features := extract_face_features(image_path)) is not None ] X, image_paths = zip(*results) if results else ([], []) return np.array(X), list(image_paths) 这里，简单说一下各个参数对于 K-Means 的影响：\\n使用 StandardScaler 对矩阵 X 进行标准化处理，将每一列的均值调整为 0，标准差调整为 1。标准化后的数据更适合 K-Means 聚类，因为 K-Means 对特征的尺度比较敏感。 参数 n_clusters 取值为 6，表示将数据分为 6 个簇，该值由最佳的 K 值确定。 参数 n_init 取值为 50，表示运行 K-Means 的次数，每次将使用不同的初始质心，确保可以得到最优结果。 参数 random_state 取值为 42，设置随机种子，确保结果可以复现。 参数 init 取值为 k-means++，表示使用 K-Means++ 算法初始化质心，避免陷入局部最优。 更多的参数及细节，请参考官方文档：https://scikit-learn.org.cn/view/108.html#2.3.2.%20K-means\\nPCA 降维与可视化 理论上，这一步可以省略。不过，为了更加直观地展示聚类结果，我们可以使用 PCA（Principal Component Analysis，主成分分析）对人脸特征进行降维，将高维特征映射到低维空间。在本文中，我们会将 128 维的特征向量映射到 2 维平面，并通过 Matplotlib 库进行可视化展示，其中的关键代码展示如下：\\nfrom sklearn.decomposition import PCA import matplotlib.pyplot as plt from matplotlib.offsetbox import OffsetImage, AnnotationBbox # 使用 PCA 降维到 2 维 pca = PCA(n_components=2) X_reduced = pca.fit_transform(X) # 获取聚类质心 centers = kmeans.cluster_centers_ centers_reduced = pca.transform(centers) # 绘制每个聚类的散点 plt.figure(figsize=(12, 10)) # 对于每个聚类，绘制聚类的点和代表性图片 for cluster in range(num_clusters): cluster_mask = labels == cluster cluster_points = X_reduced[cluster_mask] # 获取降维后的聚类中心坐标 x_center, y_center = centers_reduced[cluster] # 每个聚类的二维坐标 # 绘制聚类中的数据点 plt.scatter(cluster_points[:, 0], cluster_points[:, 1], label=f\\u0026#39;Cluster {cluster}\\u0026#39;) # 选择每个聚类中最接近聚类中心的图像 cluster_indices = np.where(cluster_mask)[0] distances = np.linalg.norm(X_reduced[cluster_mask] - centers_reduced[cluster], axis=1) closest_image_idx = cluster_indices[np.argmin(distances)] closest_image_path = image_paths[closest_image_idx] # 读取并处理该图片 img = extract_face_rect(closest_image_path) h, w = img.shape[:2] # 设定目标图像大小 target_size = 100 aspect_ratio = w / h # 根据长宽比计算新宽高 if aspect_ratio \\u0026gt; 1: new_w = target_size new_h = int(target_size / aspect_ratio) else: new_h = target_size new_w = int(target_size * aspect_ratio) # 调整图片大小 img_resized = cv2.resize(img, (new_w, new_h)) # 在聚类中心绘制代表性图片 imagebox = OffsetImage(img_resized, zoom=0.5) imagebox.image.axes = plt.gca() ab = AnnotationBbox(imagebox, (x_center, y_center),frameon=True,pad=0.5) plt.gca().add_artist(ab) # 绘制聚类中心 plt.scatter(centers_reduced[:, 0], centers_reduced[:, 1], c=\\u0026#39;red\\u0026#39;, marker=\\u0026#39;X\\u0026#39;, s=200, label=\\u0026#39;CentroIds\\u0026#39;) # 标题、标签和图例 plt.title(\\u0026#39;K-means Clustering Results (PCA Reduced)\\u0026#39;) plt.xlabel(\\u0026#39;PCA Dimension 1\\u0026#39;) plt.ylabel(\\u0026#39;PCA Dimension 2\\u0026#39;) plt.legend() plt.grid(True) plt.show() 这段代码看起来非常复杂，它具体做了什么事情呢？实际上，在通过 K-Means 聚类获得分类标签以后，我们开始尝试在每个簇的中心绘制一张人脸图片，这张图片是如何找到的呢？这里我们选取的的是离簇中心最近的那张图片。考虑到，通过 Dlib 提取的人脸特征值都是 128 维的，如果希望将其绘制到二维平面上，就需要通过 PCA 来完成降维。如图所示，通过 PCA 降维后，我们可以将聚类结果可视化。不同颜色代表不同的簇，同一簇内的点表示相似的人脸照片。通过这张图片，相信你会更加直观地理解核心点、边界点、聚类中心、重叠点等概念：\\n本文小结 本文尝试探索运用 K-Means 聚类技术对人脸照片进行快速分类的方案。首先，我们介绍了 K-Means 的基本原理及其适用范围，并探讨了如何合理确定簇数 K。随后，博主详细阐述了人脸特征的提取方法、K-Means 聚类的具体实施步骤，以及借助 PCA 降维技术实现数据可视化的流程。这一系列步骤帮助我们高效地对大量人脸照片进行分类。然而，K-Means 并非完美无瑕。它需要预先设定簇数 K，对初始中心点的选择较为敏感，且默认簇为球形或凸形。这导致其在处理非凸形簇或含噪声数据时表现不佳。针对这些局限性，实际应用中可以考虑使用 DBSCAN 等聚类算法，这类方法通常能够自动确定簇的数量，并对噪声数据具有更强的适应性。作为一种经典的聚类算法，K-Means 具有计算高效、实现简单的优点。然而，在普适性、精确度以及对深度特征的利用上，相较于基于深度学习的聚类方法，K-Means 存在一定不足。本文旨在为读者提供一种基础思路，激发其对于聚类分析这一领域的兴趣。本文代码已上传至 Github，更多细节请参考：https://github.com/Regularly-Archive/2024/blob/main/face-classify/kmeans_cluster_classify.py。\\n\"",
            "url": "\"/posts/face-photo-fast-classification-using-k-means-clustering/\"",
            "date": "\"2025-01-14\""
        },
        
        {
            "title": "\"使用 HttpMessageHandler 实现 HttpClient 请求管道自定义\"",
            "content": "\"最近，博主偶然间在 博客园 看到一篇文章：ASP.NET Core 扩展库之 Http 请求模拟，它里面介绍了一种利用 HttpMessageHandler 来实现 Http 请求模拟的方案。在日常工作中，我们总是不可避免地要和第三方的服务或者接口打交道，尤其是当我们需要面对“联调”这样一件事情的时候。通常，我们可以通过类似 YAPI 这样的工具来对尚在开发中的接口进行模拟。可是，因为这种方式会让我们的测试代码依赖于一个外部工具，所以，从严格意义上讲，它其实应该属于“集成测试”的范畴。在接触前端开发的过程中，对于其中的 Mock.js 印象深刻。故而，当看到 .NET 中有类似实现的时候，好奇心驱使我对其中的核心，即 HttpMessageHandler 产生了浓厚的兴趣。平时，我们更多的是使用 Moq 这样的库来模拟某一个对象的行为，而对一个 Http 请求进行模拟，可以说是开天辟地头一遭。带着这些问题出发，就有了今天这篇博客，通过 HttpMessageHandler 实现 HttpClient 请求管道的自定义。\\n什么是 HttpMessageHandler？ 相信大家读过我提到的文章以后，都能找到这里面最核心的一个点：HttpMessageHandler。于是，我们今天要面对的第一个问题就是，什么是 HttpMessageHandler？此时，我们需要一张历久弥新的示意图，来自 微软官方。这里，我们重点关注的是 DelegatingHandler，它继承自 HttpMessageHandler。通过这张图，我们能够获得哪些信息呢？\\n我认为，主要有以下几点：第一，HttpMessageHandler 处于整个 Http 请求管道的第一梯队，每一个路由匹配的请求都会从这里“进入”和“离开”；第二，HttpMessageHandler 可以是全局配置或者针对某个特定的路由，只要这个路由被匹配到就会执行；第三，HttpMessageHandler 可以直接构造 Http 响应并且返回，跳过剩余的管道流程。不知道大家看到这里会想到什么？坦白讲，我联想到了.NET Core 中的中间件，而唯一不同的地方或许是，中间件是 ASP.NET Core 里的概念，这里则是 ASP.NET Web API 里的概念。尤其是第三点，它对于我们的意义非常重大，因为它，我们才可以做到对一个 Http 请求进行模拟。\\n而事实上，在 ASP.NET Web API 的设计中，它是由一组 HttpMessageHandler 经过“首尾相连”而成，这种管道式的设计使得框架本身具有很高的扩展性。虽然，作为一个服务端框架，ASP.NET Web API 最主要的作用是就是“处理请求、响应回复”，可具体采用的处理策略会因具体场景的不同而不同。所以，管道式设计的本质，就是让某一个 Handler 只负责某个单一的消息处理功能，在根据具体场景的不同，选择需要的 Handler 并将其串联成一个完整的消息处理通道。而在这里，这个负责单一的消息处理功能的 Handler 其实就是 HttpMessageHandler，因为它不单单可以对请求消息(HttpRequestMessage)进行处理，同时还可以对响应消息(HttpResponseMessage)进行处理。此时，我们就不难理解 HttpMessageHandler 的定义：\\npublic abstract class HttpMessageHandler : IDisposable { protected HttpMessageHandler(); public void Dispose(); protected virtual void Dispose(bool disposing); protected internal virtual HttpResponseMessage Send( HttpRequestMessage request, CancellationToken cancellationToken ); protected internal abstract Task\\u0026lt;HttpResponseMessage\\u0026gt; SendAsync( HttpRequestMessage request, CancellationToken cancellationToken ); } 也许，你会忍不住问这样一个问题：DelegatingHandler 和 HttpMessageHandler 的区别是什么？ 其实，只要你稍微仔细一点，你就会发现，两者最大的区别是 DelegatingHandler 里新增一个叫做 InnerHandler 的成员，它本身就是一个 HttpMessageHandler。所以，聪明的你又联想到什么呢？我想，或许是一个叫做 RequestDelegate 的委托，还记得我们写中间件是一直都少不了的 Next 吗？不得不说，这里越来越有中间件的味道了。你可以立马想到的一件事情是，除了最后一个 Handler 是 HttpMessageHandler 以外，剩下的前面的所有的 Handler 都是 DelegatingHandler。为什么这样说呢？因为前面的 n-1 个 Handler 都需要串联下一个 Handler，只有第 n 个 Handler可以允许短路，所以，大概就相当于 Use() 和 Run() 的区别？\\npublic abstract class DelegatingHandler : HttpMessageHandler { protected DelegatingHandler(); protected DelegatingHandler(HttpMessageHandler innerHandler); // InnerHandler是实现管道式设计的关键 public HttpMessageHandler? InnerHandler { get; set; } protected override void Dispose(bool disposing); protected internal override HttpResponseMessage Send( HttpRequestMessage request, CancellationToken cancellationToken ); protected internal override Task\\u0026lt;HttpResponseMessage\\u0026gt; SendAsync( HttpRequestMessage request, CancellationToken cancellationToken ); } 所以，此时此刻，你能否为 HttpMessageHandler 下一个清晰的定义呢？我想，或许可以这样理解，一种可以对 请求消息(HttpRequestMessage) 和 响应消息(HttpResponseMessage) 进行处理，同时多个 HttpMessageHandler 可以组成一个完整的消息处理通道的中间件。屏幕前的你又是如何理解的呢？欢迎大家在评论区留言，留下你对于 HttpMessageHandler 的想法或者认识。\\n实现自定义请求管道 好了，搞清楚 HttpMessageHandler 是什么以后，我们就可以考虑自定义请求管道的实现啦！让我们从一个最简单的示例开始，假设我们这里定义了两个自定义的 Handler，它们分别是： HandlerA 和 HandlerB，我们应该如何将其应用到具体的 HttpClient上呢？\\n// Handler A public class HandlerA : DelegatingHandler { private readonly ILogger\\u0026lt;HandlerA\\u0026gt; _logger; public HandlerA(ILogger\\u0026lt;HandlerA\\u0026gt; logger) { _logger = logger; } protected override Task\\u0026lt;HttpResponseMessage\\u0026gt; SendAsync( HttpRequestMessage request, CancellationToken cancellationToken ) { _logger.LogInformation(\\u0026#34;This is Handler A\\u0026#34;); return base.SendAsync(request, cancellationToken); } } // Handler B public class HandlerB : DelegatingHandler { private readonly ILogger\\u0026lt;HandlerB\\u0026gt; _logger; public HandlerB(ILogger\\u0026lt;HandlerB\\u0026gt; logger) { _logger = logger; } protected override Task\\u0026lt;HttpResponseMessage\\u0026gt; SendAsync( HttpRequestMessage request, CancellationToken cancellationToken ) { _logger.LogInformation(\\u0026#34;This is Handler B\\u0026#34;); return base.SendAsync(request, cancellationToken); } } 这里，我们考虑两种场景，依赖注入 和 非依赖注入。对于依赖注入的场景，我们只需要调用AddHttpMessageHandler()方法按顺序注册即可，不需要处理InnerHandler，这里遵循先注册后使用的原则；对于非依赖注入的场景，需要处理InnerHandler，并在构造HttpClient的时候作为参数传入。\\n// 依赖注入 var services = new ServiceCollection(); services.AddTransient\\u0026lt;HandlerA\\u0026gt;(); services.AddTransient\\u0026lt;HandlerB\\u0026gt;(); services.AddHttpClient(\\u0026#34;MyClient\\u0026#34;, options =\\u0026gt; { options.BaseAddress = new Uri(\\u0026#34;https://blog.yuanpei.me/\\u0026#34;); }) .AddHttpMessageHandler\\u0026lt;HandlerA\\u0026gt;() .AddHttpMessageHandler\\u0026lt;HandlerB\\u0026gt;(); // 非依赖注入 var handler = new HandlerA() { InnerHandler = new HandlerB() }; var client = new HttpClient(handler) 此时，我们就可以得到下面的结果，可以注意到的是，两个Handler的执行顺序与注册顺序一致：\\n好了，热身环节到此结束！下面，我们来开始实战，这里展示的是 HttpMessageHandler 在日志记录、请求重试 和 接口模拟等方面的应用。\\n日志记录 对于 Http 请求的日志，我们希望记录请求的Url、Http动词、请求时长等信息，而这一点，在一个大量接入第三方接口的系统或者是以 Http 驱动的微服务架构中，常常是不可或缺的一环，对于我们排查故障、监控服务非常有用。\\nprotected override async Task\\u0026lt;HttpResponseMessage\\u0026gt; SendAsync(HttpRequestMessage request, CancellationToken cancellationToken) { var correlationId = GetCorrelationId(request); using (_logger.BeginScope($\\u0026#34;correlationId={correlationId}\\u0026#34;)) { var sw = Stopwatch.StartNew(); _logger.LogInformation($\\u0026#34;Start Processing HTTP Request {request.Method} {request.RequestUri} [Correlation: {correlationId}]\\u0026#34;); var response = base.Send(request, cancellationToken); _logger.LogInformation($\\u0026#34;End Processing HTTP Request in {sw.ElapsedMilliseconds}ms {response.StatusCode}, [Correlation: {correlationId}]\\u0026#34;); return response; } } // GetCorrelationId private string GetCorrelationId(HttpRequestMessage request) { if (request.Headers.TryGetValues(\\u0026#34;X-Correlation-ID\\u0026#34;, out var values)) return values.First(); var correlationId = Guid.NewGuid().ToString(); request.Headers.Add(\\u0026#34;X-Correlation-ID\\u0026#34;, correlationId); return correlationId; } 此时，我们可以得到下面的结果：\\n请求重试 我们知道，一个系统中接入的外部因素越多，则整个系统的稳定性越低。而国内的产品通常都喜欢\\u0026quot;大而全\\u0026quot;的\\u0026quot;万物互联\\u0026quot;，所以，最实际的问题，其实就是调用一个第三方的接口，如何保证其可靠性。所以，考虑请求的故障恢复就显得非常有意义，为此，我们可以引入Polly，在实现SendAsync()方法的时候，通过Polly中的超时、重试等机制对其做一层包装：\\npublic class RetryableHttpMessageHandler : DelegatingHandler { private readonly ILogger\\u0026lt;RetryableHttpMessageHandler\\u0026gt; _logger; private readonly IAsyncPolicy\\u0026lt;HttpResponseMessage\\u0026gt; _retryPolicy; public RetryableHttpMessageHandler( ILogger\\u0026lt;RetryableHttpMessageHandler\\u0026gt; logger ) { _logger = logger; _retryPolicy = Policy\\u0026lt;HttpResponseMessage\\u0026gt; .Handle\\u0026lt;HttpRequestException\\u0026gt;() .Or\\u0026lt;TimeoutException\\u0026gt;() .OrResult(x =\\u0026gt; (int)x.StatusCode \\u0026gt;= 400) .RetryAsync(3, (ret, index) =\\u0026gt; { _logger.LogInformation($\\u0026#34;调用接口异常：{ret.Exception?.Message}，状态码：{ret.Result.StatusCode}, 正在进行第{index}次重试\\u0026#34;); }); } protected override Task\\u0026lt;HttpResponseMessage\\u0026gt; SendAsync( HttpRequestMessage request, CancellationToken cancellationToken ) { return _retryPolicy.ExecuteAsync(() =\\u0026gt; base.SendAsync(request, cancellationToken)); } } 同样地，我们这里通过HttpClient来请求指定的接口。因为，下面的接口实际上是不存在的。所以，理论上它会返回404这个状态码。而我们的重试策略是，在发生HttpRequestException或者TimeoutException异常以及 Http 响应的状态码大于 400 时，自动触发 3 次重试。\\nvar client = _clientFactory.CreateClient(\\u0026#34;ApiMock\\u0026#34;); var response = await client.GetAsync(\\u0026#34;/api/fail\\u0026#34;); 此时，我们可以得到下面的结果：\\n可以发现，不多不少刚好是 3 次。除了重试以外，Polly还支持类似超时、断路器等等不同的策略，甚至可以将它们组合起来使用，这些都属于Polly的内容，不作为本文的重点内容来讲解，感兴趣的朋友可以查阅这篇文章：.NET 开源项目 Polly 介绍。需要说明的是，微软官方提供的 Microsoft.Extensions.Http.Polly，它在IHttpClientBuilder上添加了一个名为AddPolicyHandler()的扩展方法，这里的例子可以被简化为下面这样，它和我们这里举的例子是完全一致的：\\n// 定义重试策略 var retryPolicy = Policy\\u0026lt;HttpResponseMessage\\u0026gt; .Handle\\u0026lt;HttpRequestException\\u0026gt;() .Or\\u0026lt;TimeoutException\\u0026gt;() .OrResult(x =\\u0026gt; (int)x.StatusCode \\u0026gt;= 400) .RetryAsync(3, (ret, index) =\\u0026gt; { Console.WriteLine($\\u0026#34;调用接口异常：{ret.Exception?.Message}，状态码：{ret.Result.StatusCode}, 正在进行第{index}次重试\\u0026#34;); }); // 注册HttpClient并指定重试策略 services.AddHttpClient(\\u0026#34;ApiMock\\u0026#34;, options =\\u0026gt; { options.BaseAddress = new Uri(\\u0026#34;https://blog.yuanpei.me\\u0026#34;); }) .AddPolicyHandler(retryPolicy); 接口模拟 在集成第三方接口时，在双方确定好接口以后，接口消费方会有一段时间的“黒写”时期。因为在接口提供方的接口没有正式提供前，接口消费方始终只能通过“模拟”的方式来进行测试。考虑到单元测试对 YAPI 存在耦合，所以，接口模拟同样是一件意义非凡的事情。这里的思路是利用 HttpMessageHandler 的“短路”功能，即构造一个 HttpResponseMessage 并返回。\\n首先，我们定义一个MockItem类型，它含有两个委托类型的属性RouteSelector和Executor。其中，前者用来匹配路由，而后者则用来处理接口返回值。\\npublic class MockItem { public Func\\u0026lt;HttpRequestMessage, bool\\u0026gt; RouteSelector { get; set; } public Func\\u0026lt;HttpRequestMessage, HttpResponseMessage, Task\\u0026gt; Executor { get; set; } } 接下来，我们需要定义相应的Handler，这里是ApiMockHttpMessageHandler：\\npublic class ApiMockHttpMessageHandler: DelegatingHandler { private readonly ILogger\\u0026lt;ApiMockHttpMessageHandler\\u0026gt; _logger; private readonly IEnumerable\\u0026lt;MockItem\\u0026gt; _routes; public ApiMockHttpMessageHandler( ILogger\\u0026lt;ApiMockHttpMessageHandler\\u0026gt; logger, IEnumerable\\u0026lt;MockItem\\u0026gt; routes) { _logger = logger; _routes = routes; } protected override async Task\\u0026lt;HttpResponseMessage\\u0026gt; SendAsync( HttpRequestMessage request, CancellationToken cancellationToken ) { // 匹配路由并调用其Executor属性 var route = _routes.FirstOrDefault(x =\\u0026gt; x.RouteSelector?.Invoke(request)); if (route != null) { var response = new HttpResponseMessage(); await route.Executor?.Invoke(request, response); return response; } return base.Send(request, cancellationToken); } } 我们的思路是，对于所有注入到Ioc容器中的MockItem，检查其路由是否匹配，如果路由匹配，则通过其指定的Executor对HttpResponseMessage进行加工并返回。为了更加方便地在Ioc容器中进行注入，我们为IServiceCollection编写了相应的扩展方法：\\npublic static IServiceCollection AddMock\\u0026lt;TReturn\\u0026gt;( this IServiceCollection services, string url, HttpMethod method, TReturn @return ) { var mockItem = new MockItem(); mockItem.Executor = BuildExecutor\\u0026lt;TReturn\\u0026gt;(@return); mockItem.RouteSelector = BuildRouteSelector(url, method); return services.AddTransient\\u0026lt;MockItem\\u0026gt;(sp =\\u0026gt; mockItem); } public static IServiceCollection AddMock\\u0026lt;TReturn\\u0026gt;( this IServiceCollection services, Func\\u0026lt;HttpRequestMessage, bool\\u0026gt; routeSelector, Func\\u0026lt;HttpRequestMessage, HttpResponseMessage, Task\\u0026gt; executor ) { var mockItem = new MockItem(); mockItem.Executor = executor; mockItem.RouteSelector = routeSelector; return services.AddTransient\\u0026lt;MockItem\\u0026gt;(sp =\\u0026gt; mockItem); } private static Func\\u0026lt;HttpRequestMessage, bool\\u0026gt; BuildRouteSelector( string url, HttpMethod method ) { Func\\u0026lt;HttpRequestMessage, bool\\u0026gt; selector = request =\\u0026gt; { if (url == \\u0026#34;*\\u0026#34;) return true; return url.ToLower() == res.RequestUri.AbsolutePath.ToLower() \\u0026amp;\\u0026amp; method == res.Method; }; return selector; } private static Func\\u0026lt;HttpRequestMessage, HttpResponseMessage, Task\\u0026gt; BuildExecutor\\u0026lt;TReturn\\u0026gt;(TReturn @return) { Func\\u0026lt;HttpRequestMessage, HttpResponseMessage, Task\\u0026gt; executor = (request, response) =\\u0026gt; { response.StatusCode = System.Net.HttpStatusCode.OK; if (@return is HttpStatusCode) response.StatusCode = (HttpStatusCode)Enum.Parse( typeof(HttpStatusCode), @return.ToString() ); else if (@return is Exception) throw @return as Exception; else if (@return is string) response.Content = new StringContent(@return as string); else response.Content = new StringContent(@return == null ? \\u0026#34;\\u0026#34; : JsonConvert.SerializeObject(@return) ); return Task.CompletedTask; }; return executor; } 此时，我们就可以在单元测试中对接口进行模拟，这样就实现了真正意义上的单元测试：\\nvar services = new ServiceCollection(); // 添加 HttpClient并注册ApiMockHttpMessageHandler services.AddHttpClient(\\u0026#34;ApiMock\\u0026#34;, options =\\u0026gt; { options.BaseAddress = new Uri(\\u0026#34;https://blog.yuanpei.me\\u0026#34;); }) .AddHttpMessageHandler\\u0026lt;ApiMockHttpMessageHandler\\u0026gt;(); // 添加3个模拟接口 services.AddMock(\\u0026#34;/api/status\\u0026#34;, HttpMethod.Get, HttpStatusCode.OK); services.AddMock(\\u0026#34;/api/query\\u0026#34;, HttpMethod.Post, new Exception(\\u0026#34;帅哥你谁啊\\u0026#34;)); services.AddMock(\\u0026#34;/api/order\\u0026#34;, HttpMethod.Get, new { OrderId = \\u0026#34;OR09874\\u0026#34;, CreatedBy = \\u0026#34;张三\\u0026#34; }); var serviceProvider = services.BuildServiceProvider(); var httpClientFactory = serviceProvider.GetRequiredService\\u0026lt;IHttpClientFactory\\u0026gt;(); var httpClient = httpClientFactory.CreateClient(\\u0026#34;ApiMock\\u0026#34;); // 调用/api/order接口 var response = await httpClient.GetAsync(\\u0026#34;/api/order\\u0026#34;); 下图是模拟接口返回的结果，与我们期望的完全一致：\\n本文小结 古人云：他山之石，可以攻玉。原本被接口模拟(Mock)所吸引的博主，意外地收获了 HttpMessageHandler 这个令人兴奋的知识点。博主认为，它是一种可以对 请求消息(HttpRequestMessage) 和 响应消息(HttpResponseMessage) 进行处理，同时多个 HttpMessageHandler 可以组成一个完整的消息处理通道的中间件。在此基础上，我们实现了诸如日志记录、请求重试、接口模拟等等的扩展性功能。除此以外，它还可以应用到 Http认证头处理 、客户端负载均衡等方面。\\n其实，从 ASP.NET、OWIN、Nancy、ASP.NET Core 这样一路走过来，你会发现，管道的概念一直都存在，无非是以不同的形式存在着，譬如 ASP.NET Core 里的中间件，其实是替代了曾经的 HttpHandler 和 HttpModule，就像时间一直都在那里，不快不慢，觉得物是人非、喜新厌旧的多半还是我们。对我而言，写到这里，最大的感慨或许是，曾经试图实现的类似 Servlet 的 Http Server ，现在想起来还是太年轻、太朴实了，可年轻或者朴实，难道不好吗？好了，以上就是这篇博客的全部内容了，如果你觉得这篇博客对你有所帮助或者启发，希望你可以毫不吝啬地给个一键三连。如果你对这篇博客里的内容有意见或者建议，欢迎你评论区留下你的足迹和声音，谢谢大家！\\n\"",
            "url": "\"/posts/2070070822/\"",
            "date": "\"2021-04-28\""
        },
        
        {
            "title": "\"低代码，想说爱你不容易\"",
            "content": "\"一直想写篇文章，聊一聊“低代码”这个话题。一方面，“低代码”这个概念确实非常火，其热度丝毫不亚于曾经的“中台”。有人说，2021 年是属于“云原生”的时代，看起来我们每一年都在被技术的“娱乐圈”抛弃，明明连 Kubernetes 都还没有入门呢？人们已然在欢呼雀跃般地声称要抛弃 Docker 。这个世界有时就是如此地魔幻，明明我们生活在一个拥有大量基础设施的时代，我们不必再像前辈们“刀耕火种”一般地去开发软件，可我们的生存空间为什么就越来越狭窄了呢？拼多多事件过去没有多久，腾讯的阳光普照奖再次让“打工魂”觉醒，也许果真像大鱼海棠里设定的一样，人的记忆只有 7 秒。而另一方面，我想结合我最近开发“工作流”的感受，来吐槽下这个看起来美好的“低代码”。也许，对企业而言，引入“低代码”的确能减少研发成本，可博主并不认为，它会降低业务本身的复杂性，如果所有声称“低代码”或者“无代码”的项目，最终依然需要研发人员来作为收场。对此，我想说，对不起，这不是我想要的“低代码”。\\n低代码发展现状 或许，一个人成熟的标志就是，在面对一个未知的事物的时候，决不会不由分说地一通吐槽，就像一个人在职场上，你不能永远都只是学会抱怨，相对于抱怨，人们更希望听到的是解决方案。所以，一个人的成长，本质上就是不断学会为自己、为别人找解决方案的过程，前者是为了认识自我，而后者是为了交换资源。所以，在听我吐槽“低代码”前，不妨先一起来看看低代码的发展现状。\\n国外趋势 有人认为，“低代码”的兴起源于钉钉的低代码应用 易搭 的落地。诚然，巨头企业的每一个动向都引领着整个行业的风潮，可低代码这个概念最早要追溯到 1980 年。彼时，IBM 的快速应用程序开发工具(RAD)被冠以新的名字——低代码，这是低代码这个概念首次面向大众，此后的 40 年里，国外诞生了诸如 Outsystem 、Mendix 、 Zoho Creator 等等的产品，整体发展相对缓慢。直到 2015 年以后，AWS、Google、Microsoft 和 Oracle 等巨头开始入局低代码领域。2018 年，西门子更是宣布以 6 亿欧元收购低代码应用开发领域的领导者 Mendix 、快速应用开发的低代码平台 Outsystem 获得 3.6 亿美金的投资，低代码平台市场开始火爆起来，我们所熟悉的 Power Platform，其实就是微软的低代码开发平台，低代码领域通常都需要大量的积累和研发，需要有 10 到 20 年左右的技术沉淀。\\n国内风云 国内的低代码领域，相比国外发展起步较晚，可依然涌现出像牛刀、APICloud、iVX、搭搭云、氚云、简道云、云表、宜搭云等等产品。从整体上而言，这类这类产品基本上都提供了可视化搭建环境，都声称无需编码即可完成业务系统的搭建。其实，从一名程序员的初心出发，我们所做的一切努力都是为了以后不写代码。经常有人问，怎么样可以做到零缺陷、零 Bug ，其实不写代码就好啦！我们并不担心低代码让我们失业，相反地，如果低代码可以消化掉 30% 的垃圾项目，那么，我们将会有更多的时间去做些有意义的事情，而不是在一个“劣币驱逐良币”的市场里，靠着 996 来争个你死我活。而从低代码的商业价值角度来看，Salesforce、Appian、Joget 这三家公司均已上市，Mendix 和 Outsystem 更是估值 10 亿美元以上的独角兽公司，这正是巨头们入局低代码的原因所在。\\n低代码领域，目前关注的重点主要集中在：表单生成和处理、工作流生成和管理、办公协作、人力资源、客户关系、ERP 等企业应用上，就如同 SAP 、金蝶、 SCM 等企业软件一样，每一个软件都曾声称能帮助企业解决某一类问题，低代码领域同样遵循“二八原则”，即 80% 的场景，通过定义的方法论、方式、工具集能够实现；而剩下的 20% 的场景或许实现不了，需要使用者通过扩展的方式来自行解决。譬如，针对大多数企业都存在的 CRUD 的需求，通过在线的 Excel 表格来实现基于表的业务驱动。例如 SeaTable 就是这类主打协同工作的产品；针对大多数企业都存在的审批类的需求，则可以通过可视化的工作流设计系统来完成。例如 葡萄城 的 SpreadJS 和 活字格 ，同样可以视为低代码平台，甚至早期的 .NET 开发者被人“黑”只会拖控件，这难道不是广义上的低代码吗？\\n低代码产品形态 搞清楚整个低代码的发展现状以后，那么，整个低代码领域主要的产品形态有哪些呢？了解其主要的产品形态，对于我们形成低代码的直观印象非常有帮助。在我看来，主要分为四类：\\n表单生成类：以 宜搭云 和 JNPF 为代表，主张通过可视化的设计器来完成页面布局、编排、设计，即所谓的“所见即所得”，类似的还有 iVX。 工作流生成类：以 Mendix 和 Outsystems 为代表，提供组件式的服务，通过编排工作流来实现特定的业务，即通过流程图的方式来实现业务逻辑部分，不同的节点代表不同的功能，不同的线条代表不同的分支。 协同工作类：以 SeaTable 为代表，基于表的业务驱动开发平台，可以以不同的维度管理数据、对数据可视化、共享协作等等，同时具备自动化规则、脚本运行等能力。 服务聚合类：以 APICloud 为代表，基于 API 聚合的组件市场工具，通过流程管理工具，可以管理整个应用的开发周期，从产品、设计开始，到研发测试和运营。 所以，整体而言，低代码产品的核心是表单引擎 和 流程引擎(BPM)，外围支撑是BI 引擎、*协同工作、服务聚合等等，目前，市面上主流的低代码产品，表单引擎和流程引擎(BPM)基本是标配，所以，严格地说起来，上面的分类并不严谨，因为基本上都是混合式的产品形态。下面是部分低代码产品的截图：\\n低代码研发痛点 相信大家都知道了，接下来的内容是本文真正的重点。为什么要这样说呢？这主要和博主自身的工作有关系，简单来说，公司需要一个想象中的可视化设计器，业务人员只需要通过拖拽就可以完成业务逻辑的编排，而开发人员则需要负责对外输出组件供业务人员使用。这听起来特别像我们刚刚讨论的第二种产品形态对不对？听起来非常美好对不对？我承认这个想法真的符合潮流、非常的“低代码”。所以，我们前期采用了微软的 Windows Workflow Foundation 框架，使用以后的效果大概是下面这个样子：\\n多人协作不便 那么，我们在这个过程中到底遇到了哪些问题呢？首先，这种可视化编辑的场景，遇到的第一个问题就是多人协作，如果你使用过腾讯文档、钉钉文档这类在线文档类产品，你应该能领悟到我说的这个点。微软的这个框架是采用XMAL这种格式来储存数据的，虽然理论上可以通过 Git 实现多人协作，实际维护起来表示非常地麻烦，所以，我们最终由单人去维护这些工作流。那么，更广义上的低代码又该如何解决这个问题呢？流程图这种东西，就是一种看起来非常清晰，改起来非常麻烦的东西，就像一条锁链一样，你要不停地断开和接上。\\n孱弱的表达能力 其次，是流程图这种表现方式的“表达”问题，就像你如果需要在SQL里表示循环要用到游标一样，这类工作流都无法表达程序三个结构中的循环，更不用说表达力孱弱的表达式啦，所以，这就造成一个非常尴尬的问题，你在流程图里写不了太复杂的表达式，一旦业务人员写不出来，就需要开发人员去写辅助性质的代码，类似正则、字符串插值、字符串处理、格式化等等的函数或者 API 非常缺乏。当然，我最无法忍受的，就是组件与组件间传值的方式，你除了返回 JSON 和写表再没有其它方式，更何况这个 JSON 返回给某个组件了，人家还未必能直接解析直接使用呢？因为编辑器无法绑定这种复杂的数据结构。\\n混乱的变量和参数 接下来，我最想吐槽的是，关于全局变量和参数的问题，在流程图中你经常需要各个分支的标志位(Flag)或者是临时变量，然后你就看到了那种“变量满天飞”的混乱局面，简直像极了你刚开始写的代码，你需要顺着每个线条，逐个点开每个组件的属性面板，查看它都使用了哪些参数或者变量，至此，你终于明白了它的数据是如何流动的。从前，乡愁是成千上万行的代码；现在，乡愁是剪不断理还乱的“蜘蛛网”。多年前，我对虚幻引擎(Unreal)的蓝图功能有多么憧憬；多年后，我对这种基于流程引擎的低代码就有多排斥。尤其是，当我需要复用某一段逻辑的时候，我只能小心翼翼地选中节点和线条，然后再拷贝过去。\\n动态计算/事件顺序/黑盒子 最后，我参考了一位被 Power Apps 所折磨的朋友的意见，除了上面提到的这些问题， 属性面板或者公式无法使用动态计算的值，类似Vue 里面的计算属性，从实际使用的体验来看，这类以流程引擎和表单引擎为主要卖点的低代码工具，其实都会存在这样的问题，而面对这种问题，一般只能通过trick的手段来解决。同样地，Power Apps 事件顺序的不确定问题，因为低代码实际上是框架提供了某种机制，可以帮你完成某个事情，所以，低代码内部对于使用者来说，完全就是一个黑盒子，譬如 Power Apps 在无网络的环境下使用会卡顿，调试起来非常不便等等。\\n本文小结 坦白来讲，这篇博客实在没什么“技术含量”，无非是按照一个月前的计划在整理内容。我对“低代码”持一种中立的态度，作为程序员，我是希望有这样的技术来简化流程，可以让研发人员从枯燥的“增删改查”中解放出来，留出时间去做更多有意义、有价值的事情。当我了解了低代码和零代码的差异以后，我突然明白，我需要的其实是零代码，因为我希望那帮业务人员能自己搞定，这样就不用再来烦我，可经历这段时间的“低代码”，我清醒地认识到，这个想法根本不现实。一来业务人员并不像他们想象的那样，除了不会写代码以外无所不能；二来业务的复杂性满足守恒定律，它永远不会消失，只会从一种形式变成另一种形式。也许，低代码真的能帮企业省不少钱；也许，企业最喜欢做的事情，就是花点小钱招人外包做这种事情。但我依然想告诫开发者们，不要去追逐这些看起来美好的东西，对企业来说，它今天使用 A 技术，明天使用 B 技术，完全无关紧要。可对于个人而言，这个选择显得非常重要。看一看曾经的 SAP 咨询顾问就知道了，如果有一天 SAP 都倒闭了，你掌握着这些只有在 SAP 上能发挥作用的技术有什么用呢？对技术人员来说，学习通用型的知识和技能，永远比把鸡蛋放在一个篮子里要更保险。\\n\"",
            "url": "\"/posts/2637069146/\"",
            "date": "\"2021-02-15\""
        },
        
        {
            "title": "\"一道 HashSet 面试题引发的蝴蝶效应\"",
            "content": "\"没错，我又借着“面试题”的名头来搞事情了，今天要说的是 HashSet ，而这确实是一个实际面试中遇到的问题。当时的场景大概是这样的，面试官在了解了你的知识广度以后，决心来考察一番你的基本功底，抛出了一个看起来平平无奇的问题：说一说你平时工作中都用到了哪些数据结构。你心想，这还不简单，Array、ArrayList、List、Dictionary、HashSet、Stack、Queue\\u0026hellip;等等各种集合类简直如数家珍，甚至你还能说出这些数据结构间的优劣以及各自使用的场景。可没想到，面试官话锋一转，直接来一句，“你能说说 HashSet 去重的原理吗”，好家伙，你这简直不按套路出牌啊\\u0026hellip;本着每次面试都有一点收获的初心，于是就有了今天这篇博客，不同的是，顺着这个思路继续深挖下去，博主又发现了几个平时关注不到的技术盲点，所以，博主称之为：一道 HashSet 面试题引发的蝴蝶效应。\\nHashSet 源代码解读 OK，首先，我们来回答第一个问题，即：HashSet 去重的原理是什么？。为此，博主翻阅了 HashSet 的 源代码。首先，我们会注意到 HashSet 的构造函数，它需要一个类型为IEqualityComparer\\u0026lt;T\\u0026gt;的参数。从这个命名上我们就可以知道，这是一个用于相等性比较的接口，我们初步推测，HashSet 去重应该和这个接口有关：\\npublic HashSet() : this(EqualityComparer\\u0026lt;T\\u0026gt;.Default) { } public HashSet(int capacity) : this(capacity, EqualityComparer\\u0026lt;T\\u0026gt;.Default) { } public HashSet(IEqualityComparer\\u0026lt;T\\u0026gt; comparer) { } public HashSet(IEnumerable\\u0026lt;T\\u0026gt; collection) : this(collection, EqualityComparer\\u0026lt;T\\u0026gt;.Default) { } public HashSet(IEnumerable\\u0026lt;T\\u0026gt; collection, IEqualityComparer\\u0026lt;T\\u0026gt; comparer) : this(comparer) { } 我们都知道 HashSet 可以去重，比如，我们向 HashSet 添加多个相同的元素，实际上 HashSet 中最终只会有一个元素。所以，我们自然而然地想到，看看 HashSet 中的 Add() 方法呗，或许能从这里看出一点端倪。HashSet 中一共有两个 Add() 方法，它们内部都调用了 AddIfNotPresent() 方法：\\nvoid ICollection\\u0026lt;T\\u0026gt;.Add(T item) { AddIfNotPresent(item); } public bool Add(T item) { return AddIfNotPresent(item); } 继续循着蛛丝马迹一路 F12 ，我们来看看这个方法的具体实现：\\nprivate bool AddIfNotPresent(T value) { if (m_buckets == null) { Initialize(0); } int hashCode = InternalGetHashCode(value); int bucket = hashCode % m_buckets.Length; #if FEATURE_RANDOMIZED_STRING_HASHING \\u0026amp;\\u0026amp; !FEATURE_NETCORE int collisionCount = 0; #endif for (int i = m_buckets[hashCode % m_buckets.Length] - 1; i \\u0026gt;= 0; i = m_slots[i].next) { if (m_slots[i].hashCode == hashCode \\u0026amp;\\u0026amp; m_comparer.Equals(m_slots[i].value, value)) { return false; } #if FEATURE_RANDOMIZED_STRING_HASHING \\u0026amp;\\u0026amp; !FEATURE_NETCORE collisionCount++; #endif } int index; if (m_freeList \\u0026gt;= 0) { index = m_freeList; m_freeList = m_slots[index].next; } else { if (m_lastIndex == m_slots.Length) { IncreaseCapacity(); // this will change during resize bucket = hashCode % m_buckets.Length; } index = m_lastIndex; m_lastIndex++; } m_slots[index].hashCode = hashCode; m_slots[index].value = value; m_slots[index].next = m_buckets[bucket] - 1; m_buckets[bucket] = index + 1; m_count++; m_version++; #if FEATURE_RANDOMIZED_STRING_HASHING \\u0026amp;\\u0026amp; !FEATURE_NETCORE if (collisionCount \\u0026gt; HashHelpers.HashCollisionThreshold \\u0026amp;\\u0026amp; HashHelpers.IsWellKnownEqualityComparer(m_comparer)) { m_comparer = (IEqualityComparer\\u0026lt;T\\u0026gt;) HashHelpers.GetRandomizedEqualityComparer(m_comparer); SetCapacity(m_buckets.Length, true); } #endif // FEATURE_RANDOMIZED_STRING_HASHING return true; } 可以注意到，在这段代码中，首先，会通过 InternalGetHashCode() 方法计算一个 HashCode。其中，Lower31BitMask 是一个常量 0x7FFFFFFF ：\\nprivate int InternalGetHashCode(T item) { if (item == null) { return 0; } return m_comparer.GetHashCode(item) \\u0026amp; Lower31BitMask; } 接下来，在 HashSet 内部使用了Slot 这个结构来存储元素，该结构设计上类似于链表，每一个 Slot 中都记录对应元素的值、HashCode 以及下一个元素的索引。所以，只需要对它做一次遍历，如果对应元素的 HashCode 和 值 都相等，则认为该元素在 HashSet中已经存在了。此时，AddIfNotPresent() 方法会返回 false。这就是 HashSet 去重的原理啦。在比较元素的值是否相等的时候，我们前面提到的 IEqualityComparer\\u0026lt;T\\u0026gt; 终于登场，它提供的 Equals() 方法恰好可以比较两个元素是否相等：\\ninternal struct Slot { internal int hashCode; // Lower 31 bits of hash code, -1 if unused internal int next; // Index of next entry, -1 if last internal T value; } public interface IEqualityComparer\\u0026lt;in T\\u0026gt; { bool Equals(T x, T y); int GetHashCode(T obj); } 再接下来，如果对应元素的 HashCode 或 值 都不相等，则认为该元素在 HashSet 中不存在。此时，需要考虑 HashSet 的容量是否足以放得下这个新元素。在容量不满足的情况下，就需要对 HashSet 进行扩容。值得一提的是，这里是使用质数进行扩容的：\\nprivate void IncreaseCapacity() { Debug.Assert(m_buckets != null, \\u0026#34;IncreaseCapacity called on a set with no elements\\u0026#34;); int newSize = HashHelpers.ExpandPrime(m_count); if (newSize \\u0026lt;= m_count) { throw new ArgumentException(SR.GetString(SR.Arg_HSCapacityOverflow)); } // Able to increase capacity; copy elements to larger array and rehash SetCapacity(newSize, false); } public static int ExpandPrime(int oldSize) { int newSize = 2 * oldSize; // Allow the hashtables to grow to maximum possible size (~2G elements) before encoutering capacity overflow. // Note that this check works even when _items.Length overflowed thanks to the (uint) cast if ((uint)newSize \\u0026gt; MaxPrimeArrayLength \\u0026amp;\\u0026amp; MaxPrimeArrayLength \\u0026gt; oldSize) { Contract.Assert( MaxPrimeArrayLength == GetPrime(MaxPrimeArrayLength), \\u0026#34;Invalid MaxPrimeArrayLength\\u0026#34;); return MaxPrimeArrayLength; } return GetPrime(newSize); } IEqualityComparer接口 OK，现在我们知道了，HashSet 之所以可以去重，一个重要的原因是 IEqualityComparer\\u0026lt;T\\u0026gt; 。而回到这个接口本身呢，它只有 Equals() 和 GetHashCode()，这其实非常符合我们的认知，因为这两个方法在对象相等的场景中十分常见，有一个准则是：如果重写了 Equals() 方法，那么，应该同时去重写 GetHashCode() 方法，即，两者在表达相等这个含义时应该具有一致性。这里可能会有一点疑问，那就是，我们平时使用 HashSet 的时候，完全不需要指定 IEqualityComparer\\u0026lt;T\\u0026gt; ，它一样可以正常工作啊？没错，这是因为微软提供了一个默认的实现：EqualityComparer\\u0026lt;T\\u0026gt;.Default。我们同样来看看它的实现：\\nprivate static EqualityComparer\\u0026lt;T\\u0026gt; CreateComparer() { Contract.Ensures(Contract.Result\\u0026lt;EqualityComparer\\u0026lt;T\\u0026gt;\\u0026gt;() != null); RuntimeType t = (RuntimeType)typeof(T); // Specialize type byte for performance reasons if (t == typeof(byte)) { return (EqualityComparer\\u0026lt;T\\u0026gt;)(object)(new ByteEqualityComparer()); } // If T implements IEquatable\\u0026lt;T\\u0026gt; return a GenericEqualityComparer\\u0026lt;T\\u0026gt; if (typeof(IEquatable\\u0026lt;T\\u0026gt;).IsAssignableFrom(t)) { return (EqualityComparer\\u0026lt;T\\u0026gt;)RuntimeTypeHandle.CreateInstanceForAnotherGenericParameter((RuntimeType)typeof(GenericEqualityComparer\\u0026lt;int\\u0026gt;), t); } // If T is a Nullable\\u0026lt;U\\u0026gt; where U implements IEquatable\\u0026lt;U\\u0026gt; return a NullableEqualityComparer\\u0026lt;U\\u0026gt; if (t.IsGenericType \\u0026amp;\\u0026amp; t.GetGenericTypeDefinition() == typeof(Nullable\\u0026lt;\\u0026gt;)) { RuntimeType u = (RuntimeType)t.GetGenericArguments()[0]; if (typeof(IEquatable\\u0026lt;\\u0026gt;).MakeGenericType(u).IsAssignableFrom(u)) { return (EqualityComparer\\u0026lt;T\\u0026gt;)RuntimeTypeHandle.CreateInstanceForAnotherGenericParameter((RuntimeType)typeof(NullableEqualityComparer\\u0026lt;int\\u0026gt;), u); } } // See the METHOD__JIT_HELPERS__UNSAFE_ENUM_CAST and METHOD__JIT_HELPERS__UNSAFE_ENUM_CAST_LONG cases in getILIntrinsicImplementation if (t.IsEnum) { TypeCode underlyingTypeCode = Type.GetTypeCode(Enum.GetUnderlyingType(t)); // Depending on the enum type, we need to special case the comparers so that we avoid boxing // Note: We have different comparers for Short and SByte because for those types we need to make sure we call GetHashCode on the actual underlying type as the // implementation of GetHashCode is more complex than for the other types. switch (underlyingTypeCode) { case TypeCode.Int16: // short return (EqualityComparer\\u0026lt;T\\u0026gt;)RuntimeTypeHandle.CreateInstanceForAnotherGenericParameter((RuntimeType)typeof(ShortEnumEqualityComparer\\u0026lt;short\\u0026gt;), t); case TypeCode.SByte: return (EqualityComparer\\u0026lt;T\\u0026gt;)RuntimeTypeHandle.CreateInstanceForAnotherGenericParameter((RuntimeType)typeof(SByteEnumEqualityComparer\\u0026lt;sbyte\\u0026gt;), t); case TypeCode.Int32: case TypeCode.UInt32: case TypeCode.Byte: case TypeCode.UInt16: //ushort return (EqualityComparer\\u0026lt;T\\u0026gt;)RuntimeTypeHandle.CreateInstanceForAnotherGenericParameter((RuntimeType)typeof(EnumEqualityComparer\\u0026lt;int\\u0026gt;), t); case TypeCode.Int64: case TypeCode.UInt64: return (EqualityComparer\\u0026lt;T\\u0026gt;)RuntimeTypeHandle.CreateInstanceForAnotherGenericParameter((RuntimeType)typeof(LongEnumEqualityComparer\\u0026lt;long\\u0026gt;), t); } } // Otherwise return an ObjectEqualityComparer\\u0026lt;T\\u0026gt; return new ObjectEqualityComparer\\u0026lt;T\\u0026gt;(); } 在这里，EqualityComparer\\u0026lt;T\\u0026gt; 类是一个抽象类，实现了 IEqualityComparer\\u0026lt;T\\u0026gt; 接口。简单来说，对于简单类型如整型、字节型等，微软实现了相应的 IEqualityComparer\\u0026lt;T\\u0026gt; 接口；而对于复杂的类型，微软提供了 ObjectEqualityComparer\\u0026lt;T\\u0026gt; 这一实现：\\ninternal class ObjectEqualityComparer\\u0026lt;T\\u0026gt;: EqualityComparer\\u0026lt;T\\u0026gt; { [Pure] public override bool Equals(T x, T y) { if (x != null) { if (y != null) return x.Equals(y); return false; } if (y != null) return false; return true; } [Pure] public override int GetHashCode(T obj) { if (obj == null) return 0; return obj.GetHashCode(); } } 所以，现在又回到我们刚刚聊起的话题，为什么说一个类型的 Equals() 和 GetHashCode() 方法非常重要呢？因为如果我们不能正确地实现这两个方法，微软实现的这个 ObjectEqualityComparer\\u0026lt;T\\u0026gt; 就会出现问题，导致 HashSet 在判断元素是否存在时出现问题，所以，这是一系列的连锁反应。有人可能会问，博主你说的这个好夸张耶，像我就从来没有重写过这两个方法。OK，现在来回答我的一个问题，如果你定义了一个类型 Foo ，并尝试用它作为一个字典中的 Key ，那么，你觉得这个字典应该怎么判断这个 Key 是否存在呢？我觉得这是一个好问题，因为它引发了我们在 .NET 知识体系中的蝴蝶效应。\\n排序与去重是亲家 排序与去重，在我看来是亲家关系，因为两者都需要“比较”。所以，下面我想从 .NET 中选取一部分接口来阐述我的观点，以及当我们有了 LINQ 以后，是否就应该抛弃它们。可能这些接口大家平时都用不到多少，但我还是想花点时间来梳理这些知识盲点，因为我发现，与其为整个行业 35 岁的的职业生涯而焦虑，倒不如重新捡起这个行业的初心，好好地学一学数据结构、算法和数学。整个行业的火热，容易让每一个人都陷入一种“我非常厉害”的错觉，我写博客的时候，在心里想了这样一句话：战士上战场，整天就知道 CRUD，连 HashSet 都不知道，早晚是个死。用王布斯的口吻说出来，会不会有一种紧迫感呢？\\nIEquatable接口 IEquatable\\u0026lt;T\\u0026gt; 接口在微软官方文档中的定义是，定义值类型或类实现的通用方法，以创建用于确定实例相等性的类型特定方法。我承认，这不是一个特别好的定义，不过，我们可以换个角度来审视这个接口存在的意义。虽然 Object 这个基类提供了 Equals() 方法，但是这个方法只能接受一个 object 类型的参数， 所以，它本身会面临类型安全性缺失和装箱两个问题。为了解决这个问题，就必须要定义一个新的 Equals() 方法，确保它可以接收和当前类型一致的参数，所以就需要这样一个接口，你可以理解为它是 Equals() 方法的泛型版本，而众所周知 C# 是一门不支持多继承的语言，所以，这里只能以接口的形式提供出来。这里说一下我的结论，IEquatable\\u0026lt;T\\u0026gt; 接口对值类型更有用一点，相反，对引用类型就没有那么有用，因为它没有考虑到协变的问题，对引用类型的继承相对无力。下面是一个简单的例子：\\n//定义类型Foo，实现IEquatable\\u0026lt;Foo\\u0026gt;接口 public class Foo : IEquatable\\u0026lt;Foo\\u0026gt; { public decimal Value { get; set; } public decimal Weight { get; set; } public override bool Equals(object other) { return Equals(other as Foo); } public bool Equals(Foo other) { if (other == null) return false; return (this.Value == other.Value \\u0026amp;\\u0026amp; this.Weight == other.Weight); } } //平平无奇的代码 var foo1 = new Foo() { Value = 10, Weight = 1.0M }; var foo2 = new Foo() { Value = 10, Weight = 1.0M }; Assert.AreEqual(true, foo1.Equals(foo2)); ICompareable/ICompareable接口 ICompareable 和 ICompareable\\u0026lt;T\\u0026gt;是是同一个接口的非泛型与泛型版本，都需要实现 CompareTo() 方法。可能大家会觉得这几个接口都差不多啊，实际上，大家细心观察就能发现它们的区别，“相等”这一类的接口的返回值是布尔型，关注的是两个对象是否相等；而“比较”这一类的接口的返回值是整数型，关注的是哪个大哪个小。我们继续以 Foo 这个类型为例，分别实现IComparerable 和 IComparerable\\u0026lt;T\\u0026gt;两个接口：\\n//继续实现IComparable, IComparable\\u0026lt;Foo\\u0026gt;接口 public class Foo : IEquatable\\u0026lt;Foo\\u0026gt;, IComparable, IComparable\\u0026lt;Foo\\u0026gt; { public decimal Value { get; set; } public decimal Weight { get; set; } public override bool Equals(object other) { return Equals(other as Foo); } public bool Equals(Foo other) { if (other == null) return false; return (this.Value == other.Value \\u0026amp;\\u0026amp; this.Weight == other.Weight); } public int CompareTo(object obj) { var other = obj as Foo; return CompareTo(other); } public int CompareTo([AllowNull] Foo other) { if (other == null) return 1; return (int)((Value * Weight) - (other.Value * other.Weight)); } } //平平无奇的代码 var foo1 = new Foo() { Value = 10, Weight = 1.0M }; var foo2 = new Foo() { Value = 20, Weight = 1.0M }; Assert.IsTrue(foo2.CompareTo(foo1) \\u0026gt; 0); IComparer接口 对于排序来说，理论上有ICompareable 和 ICompareable\\u0026lt;T\\u0026gt;这两个接口就可以了，为什么还要再定义一组接口呢？其实，我们结合生活中的场景就能想明白，不管是判断两个对象是否相等，还是对两个对象进行排序，这些条件都属于“变量”。ICompareable 和 ICompareable\\u0026lt;T\\u0026gt;这两个接口设计上的确没什么问题，但这都是一锤子买卖，一旦实现了对应的接口，就意味着如何比较两个对象的逻辑是确定好了的。可生活常识告诉我们，同一组信息不同的人考虑的维度是不一样的，譬如学生的成绩，可以按照某一个科目的成绩来排序，还可以按照各个科目的总成绩甚至是平均分来排序。对于上面的类型 Foo，我们不妨考虑按照 Value 和 Weight 分别进行排序，此时可以这样写：\\n//按Value排序 public class FooValueComparer : IComparer\\u0026lt;Foo\\u0026gt; { public int Compare([AllowNull] Foo x, [AllowNull] Foo y) { if (x == null \\u0026amp;\\u0026amp; y == null) return 0; if (x != null \\u0026amp;\\u0026amp; y == null) return 1; if (x == null \\u0026amp;\\u0026amp; y != null) return -1; return (int)(x.Value - y.Value); } } //按Weight排序 public class FooWeightComparer : IComparer\\u0026lt;Foo\\u0026gt; { public int Compare([AllowNull] Foo x, [AllowNull] Foo y) { if (x == null \\u0026amp;\\u0026amp; y == null) return 0; if (x != null \\u0026amp;\\u0026amp; y == null) return 1; if (x == null \\u0026amp;\\u0026amp; y != null) return -1; return (int)(x.Weight - y.Weight); } } //平平无奇的代码 var list= new List\\u0026lt;Foo\\u0026gt;{ new Foo() { Value = 10, Weight = 2.0M }, new Foo() { Value = 10, Weight = 1.0M } }; //使用默认的排序器 list.Sort(); //按Value进行排序 list.Sort(new FooValueComparer()); list.OrderBy(x =\\u0026gt; x.Value); //按Weight进行排序 list.Sort(new FooWeightComparer()); list.OrderBy(x =\\u0026gt; x.Weight); 在这里有一个点是，在不指定排序器的时候，微软帮我们提供了一个默认的排序器。而这个默认排序器会遵循这样的策略。如果类型 T 实现了 IComparable\\u0026lt;T\\u0026gt; 接口，则返回 GenericComparer\\u0026lt;int\\u0026gt; 实例；如果类型 T 实现是一个可空类型 Nullable\\u0026lt;U\\u0026gt; 并且类型 U 实现了 IComparable\\u0026lt;T\\u0026gt; 接口，则返回 NullableComparer\\u0026lt;int\\u0026gt; 实例；否则返回 ObjectComparer\\u0026lt;T\\u0026gt; 实例。\\nprivate static Comparer\\u0026lt;T\\u0026gt; CreateComparer() { RuntimeType t = (RuntimeType)typeof(T); // If T implements IComparable\\u0026lt;T\\u0026gt; return a GenericComparer\\u0026lt;T\\u0026gt; #if FEATURE_LEGACYNETCF // Pre-Apollo Windows Phone call the overload that sorts the keys, not values this achieves the same result if (CompatibilitySwitches.IsAppEarlierThanWindowsPhone8) { if (t.ImplementInterface(typeof(IComparable\\u0026lt;T\\u0026gt;))) { return (Comparer\\u0026lt;T\\u0026gt;)RuntimeTypeHandle.CreateInstanceForAnotherGenericParameter((RuntimeType)typeof(GenericComparer\\u0026lt;int\\u0026gt;), t); } } else #endif if (typeof(IComparable\\u0026lt;T\\u0026gt;).IsAssignableFrom(t)) { return (Comparer\\u0026lt;T\\u0026gt;)RuntimeTypeHandle.CreateInstanceForAnotherGenericParameter((RuntimeType)typeof(GenericComparer\\u0026lt;int\\u0026gt;), t); } // If T is a Nullable\\u0026lt;U\\u0026gt; where U implements IComparable\\u0026lt;U\\u0026gt; return a NullableComparer\\u0026lt;U\\u0026gt; if (t.IsGenericType \\u0026amp;\\u0026amp; t.GetGenericTypeDefinition() == typeof(Nullable\\u0026lt;\\u0026gt;)) { RuntimeType u = (RuntimeType)t.GetGenericArguments()[0]; if (typeof(IComparable\\u0026lt;\\u0026gt;).MakeGenericType(u).IsAssignableFrom(u)) { return (Comparer\\u0026lt;T\\u0026gt;)RuntimeTypeHandle.CreateInstanceForAnotherGenericParameter((RuntimeType)typeof(NullableComparer\\u0026lt;int\\u0026gt;), u); } } // Otherwise return an ObjectComparer\\u0026lt;T\\u0026gt; return new ObjectComparer\\u0026lt;T\\u0026gt;(); } 更有意思的是，GenericComparer\\u0026lt;T\\u0026gt; 就是利用 IComparable\\u0026lt;T\\u0026gt; 的 CompareTo() 方法来说实现的：\\ninternal class GenericComparer\\u0026lt;T\\u0026gt; : Comparer\\u0026lt;T\\u0026gt; where T: IComparable\\u0026lt;T\\u0026gt; { public override int Compare(T x, T y) { if (x != null) { if (y != null) return x.CompareTo(y); return 1; } if (y != null) return -1; return 0; } // Equals method for the comparer itself. public override bool Equals(Object obj){ GenericComparer\\u0026lt;T\\u0026gt; comparer = obj as GenericComparer\\u0026lt;T\\u0026gt;; return comparer != null; } public override int GetHashCode() { return this.GetType().Name.GetHashCode(); } } 在我们有了 LINQ 以后，通过 OrderBy 和 OrderByDescending 就可以进行排序，如果这个排序字段是一个简单类型，比如字符型、整型、日期型，这些简单类型微软都已经实现了相应的“排序”逻辑，而如果这个排序字段是一个复杂类型，比如一个自定义的类或者结构，此时，为了让这些方法能够“适应”这些复杂类型，最好的还是去实现 IComparer\\u0026lt;T\\u0026gt; 或者 ICompareable\\u0026lt;T\\u0026gt; 接口，然后传递给这两个排序方法。类似地，还有 Distinct 这个方法，它接收一个 IEqualityComparer\\u0026lt;T\\u0026gt; 类型的参数，所以，当你对一个列表进行去重(Distinct)操作时，千万不要想当然地人为它会按照你的期望去去重，如果结果不符合你的期望，很大原因是你没有给它提供一个合适的IEqualityComparer\\u0026lt;T\\u0026gt; 。所以，你看，我们绕了一大圈，从 HashSet 说到 IEqualityComparer\\u0026lt;T\\u0026gt;，又从排序说到去重，最终又回到了起点，这是多么有趣的一件事情。而去重(Distinct)这件事情，其实涉及到Dictionary 和 HashSet 两个数据结构，通过结构来推演性质，又通过性质来扫清盲点，这可能是这段时间刷 LeetCode 最大的一个收获吧！\\n本文小结 面试中偶然遇到的 HashSet 问题，让我发现自己的知识体系中存在着盲点。通过解读 HashSet 源代码，我们认识到 HashSet 可以去重的一个重要原因是IEqualityComparer\\u0026lt;T\\u0026gt; 接口，它决定了两个对象的实例在什么情况下可以被判定为相等。而这个接口，不单单在 HashSet 出现，在 Dictionary 中同样会出现，甚至在我们最熟悉不过的去重(Distinct)中还会出现，所以，通过 HashSet 这一个点上的疑问，我搞清楚了很多相关联的内容，这不是蝴蝶效应又是什么呢？而与去重(Distinct)相关联的则是排序，在此基础上，对 IEquatable\\u0026lt;T\\u0026gt; 接口、ICompareable/ICompareable\\u0026lt;T\\u0026gt; 接口、IComparer\\u0026lt;T\\u0026gt; 接口等知识盲点进行梳理。总而言之，排序需要关注的是 ICompareable/ICompareable\\u0026lt;T\\u0026gt; 接口、IComparer\\u0026lt;T\\u0026gt; 接口，去重需要关注的是 IEqualityComparer\\u0026lt;T\\u0026gt; 接口。好了，今天的这只蝴蝶就飞到这里，欢迎大家在博客中留言，谢谢大家！\\n\"",
            "url": "\"/posts/3411909634/\"",
            "date": "\"2020-10-20\""
        },
        
        {
            "title": "\"使用 Dynamic Linq 构建动态 Lambda 表达式\"",
            "content": "\"相信大家都有这样一种感觉，Linq和Lambda是.NET 中一以贯之的存在，从最早的 Linq to Object 到 Linq to SQL，再到 EF/EF Core 甚至如今的.NET Core，我们可以看到Lambda表达式的身影出现地越来越频繁。虽然 Linq to Object 和 Linq to SQL，分别是以IEnumerable\\u0026lt;T\\u0026gt;和IQueryable \\u0026lt;T\\u0026gt;为基础来实现的。我个人以为，Lambda呢，其实就是匿名委托的“变种”，而Linq则是对Lambda的进一步封装。在System.Linq.Expressions命名空间下，提供大量关于表达式树的 API，而我们都知道，这些表达式树最终都会被编译为委托。所以，动态创建 Lambda 表达式，实际上就是指从一个字符串生成对应委托的过程，而一旦这个委托被生成，可以直接传递给 Where()方法作为参数，显然，它可以对源数据进行过滤，这正是我们想要的结果。\\n事出有因 在今天这篇博客中，我们主要介绍System.Linq.Dynamic.Core这个库，即我所说的 Dynamic Linq。本着“艺术源于生活的态度”，在介绍它的用法之前，不妨随博主一起看看，一个“简单“的查询是如何随着业务演进而变得越来越复杂。从某种意义上来说，正是它让博主想起了 Dynamic Linq。我们为客户编写了一个生成订单的接口，它从一张数据表中“消费”订单数据。最开始，它只需要过滤状态为“未处理”的记录，对应的 CRUD 可以表示为这样：\\nvar orderInfos = repository.GetByQuery\\u0026lt;tt_wg_order\\u0026gt;(x =\\u0026gt; x.STATUS == 10); 后来，因为业务方存在重复/错误下单的情况，业务数据有了“软删除”的状态，相应地查询条件再次发生变化，这看起来还行对吧：\\nvar orderInfos = repository.GetByQuery\\u0026lt;tt_wg_order\\u0026gt;(x =\\u0026gt; x.STATUS == 10 \\u0026amp;\\u0026amp; x.Isdelete == 0); 再后来，因为接口处理速度不理想，无法满足客户的使用场景，公司大佬们建议“加机器”，而为了让每台服务器上消费的订单数据不同(据说是为了避免发生并发)，大佬们要求博主开放所有字段作为查询条件，这样，每台服务器上可以配置不同查询条件。自此，又双叒叕改：\\nvar repository = container.Resolve\\u0026lt;CrudRepositoryBase\\u0026gt;(); var searchParameters = new SearchParameters() { PageInfo = new PageInfo() { PageSize = parameters.PAGE_SIZE.Value }}; searchParameters.QueryModel.Items.Add(new ConditionItem { Field = \\u0026#34;STATUS\\u0026#34;, Method = QueryMethod.Equal, Value = 10 }); searchParameters.QueryModel.Items.Add(new ConditionItem { Field = \\u0026#34;Isdelete\\u0026#34;, Method = QueryMethod.Equal, Value = 0 }); //此处省略更多的查询条件:) var orderInfos = repository.GetByPage\\u0026lt;tt_wg_order\\u0026gt;(searchParameters); 可以想象得出，终极终终极的查询会变成下面这张图。这种方式看起来很美好对不对？可谁能想到，就在五一放假前的某一天里，博主还在替某个“刁钻”客户排查一组同样“刁钻”的过滤条件为什么没有生效。显然，我需要有一种更友好的方式，它可以从一个字符串变成一个委托，就像 JavaScript 里\\u0026quot;邪恶\\u0026quot;的 Eval()函数一样，说它邪恶，是因为它的输入是不可控的，\\u0026ldquo;机智\\u0026quot;的人类习惯把事件万物都当成 SQL 语句，其实，RESTful 接口里传 SQL、调存储过程难道不可以吗？同样，是因为这种做法太\\u0026quot;邪恶\\u0026rdquo;。\\n![过滤条件在风中凌乱]](https://i.loli.net/2020/05/11/QEDHwA9bZUTInJY.png)\\nParseLambda 首先，通过nuget安装：System.Linq.Dynamic.Core。这里主要介绍的是介绍的是其中的 ParseLambda()方法，顾名思义，它可以把一个字符串转换为指定类型的委托，一起来看下面的例子。首先，我们定义一个通用方法 BuildLambda：\\nFunc\\u0026lt;T, bool\\u0026gt; BuildLambda\\u0026lt;T\\u0026gt;(string exps) { var sourceType = typeof(T); var sourceParameter = Expression.Parameter(sourceType); var lambdaExps = DynamicExpressionParser.ParseLambda( new[] { sourceParameter }, typeof(bool), exps ); return lambdaExps.Compile() as Func\\u0026lt;T, bool\\u0026gt;; } var students = new List\\u0026lt;Student\\u0026gt;() { new Student() { Name = \\u0026#34;长安书小妆\\u0026#34;, Age = 25, Address = \\u0026#34;洛阳市洛龙区\\u0026#34;, Teacher = new Teacher() { Name = \\u0026#34;孔子\\u0026#34; } }, new Student() { Name = \\u0026#34;飞鸿踏雪\\u0026#34;, Age = 28, Address = \\u0026#34;宁夏中卫市\\u0026#34;, Teacher = new Teacher() { Name = \\u0026#34;孔子\\u0026#34; } }, }; var exps = \\u0026#34;Age\\u0026lt;=25 \\u0026amp;\\u0026amp; Address.Contains(\\\\\\u0026#34;洛阳市\\\\\\u0026#34;) \\u0026amp;\\u0026amp; Teacher.Name=\\\\\\u0026#34;孟子\\\\\\u0026#34;\\u0026#34;; var lambda = BuildLambda\\u0026lt;Student\\u0026gt;(exps); var results = students.Where(lambda); 注意到，核心的代码其实只有DynamicExpressionParser.ParseLambda()这一句，这充分暴露了博主“调包侠”的本质。按照示例代码中的过滤条件，我们知道给定数据中是没有符合条件的数据的。假如你真的运行了这段代码，你就会得到真正的结果：我说的是对的(逃\\nOne More Thing 其实，我们今天所说这一切，从本质上来讲，还是属于表达式树的范畴，因为上面的例子，我们同样可以使用表达式树来编写，无非是这个第三方库帮我们隐藏了这部分细节。对于上面这个例子，如果用表达式树来写，会是什么样子的呢？相信熟悉表达式树的朋友，可以非常容易地写出下面的代码：\\n//x var parameter = Expression.Parameter(typeof(tt_wg_order), \\u0026#34;x\\u0026#34;); //x.STATUS == 10 var condStatus = Expression.Equal(Expression.Property(parameter, \\u0026#34;STATUS\\u0026#34;), Expression.Constant(10)); //x.Isdelete == 0 var condIsDelete = Expression.Equal(Expression.Property(parameter, \\u0026#34;Isdelete\\u0026#34;), Expression.Constant(0)); //x.STATUS == 10 \\u0026amp;\\u0026amp; x.Isdelete == 0 var condAndAlso = Expression.AndAlso(condStatus, condIsDelete); //x =\\u0026gt; x.STATUS == 10 \\u0026amp;\\u0026amp; x.Isdelete == 0 var lambda = Expression.Lambda\\u0026lt;Func\\u0026lt;tt_wg_order,bool\\u0026gt;\\u0026gt;(condAndAlso, parameter); 我们可以注意到，一个 Lmabda 表达式，可以抽象为:参数(Parameter)和函数体(Body)两部分，而Body实际上是由一个操作符和一个值组成。譬如这里的第一个条件：x.STATUS == 10。在这里基础上，我们可以定义一个类型：SearchParameters，它将每个条件抽象为字段(Field)、查询方法(QueryMethod)、值(Value)和或分组(OrGroup)。所以，它的处理逻辑就是，将相同 OrGroup 的条件放在一起用 Or 连接，然后再和其它条件放在一起用 And 连接。故而，它可以通过表达式构造出一个 Predict类型的委托，而我们的数据持久层是使用 EF 来实现的，所以，它可以顺利成章地和 IQueryable搭配使用，这就是我们这个 SearchParameters 的实现原理，它唯一让我觉得不好的地方是，字段(Field)不能通过一个 Lambda 表达式去构造，而必须传入一个字符串，这给了使用者写错字段名称的机会(逃：\\npublic static class LambdaExpressionBuilder { private static Expression GetExpression (ParameterExpression parameter, Condition condition) { var propertyParam = Expression.Property (parameter, condition.Field); var propertyInfo = propertyParam.Member as PropertyInfo; if (propertyInfo == null) throw new ArgumentException ($\\u0026#34;Invalid field \\\\\\u0026#34;{condition.Field}\\\\\\u0026#34;\\u0026#34;); var realPropertyType = Nullable.GetUnderlyingType (propertyInfo.PropertyType) ?? propertyInfo.PropertyType; if (condition.Op != Operation.StdIn \\u0026amp;\\u0026amp; condition.Op != Operation.StdNotIn) condition.Value = Convert.ChangeType (condition.Value, realPropertyType); var constantParam = Expression.Constant (condition.Value); switch (condition.Op) { case Operation.Equals: return Expression.Equal (propertyParam, constantParam); case Operation.NotEquals: return Expression.NotEqual (propertyParam, constantParam); case Operation.Contains: return Expression.Call (propertyParam, \\u0026#34;Contains\\u0026#34;, null, constantParam);; case Operation.NotContains: return Expression.Not (Expression.Call (propertyParam, \\u0026#34;Contains\\u0026#34;, null, constantParam)); case Operation.StartsWith: return Expression.Call (propertyParam, \\u0026#34;StartsWith\\u0026#34;, null, constantParam); case Operation.EndsWith: return Expression.Call (propertyParam, \\u0026#34;EndsWith\\u0026#34;, null, constantParam); case Operation.GreaterThen: return Expression.GreaterThan (propertyParam, constantParam); case Operation.GreaterThenOrEquals: return Expression.GreaterThanOrEqual (propertyParam, constantParam); case Operation.LessThan: return Expression.LessThan (propertyParam, constantParam); case Operation.LessThanOrEquals: return Expression.LessThanOrEqual (propertyParam, constantParam); case Operation.StdIn: return Expression.Call (typeof (Enumerable), \\u0026#34;Contains\\u0026#34;, new Type[] { realPropertyType }, new Expression[] { constantParam, propertyParam }); case Operation.StdNotIn: return Expression.Not (Expression.Call (typeof (Enumerable), \\u0026#34;Contains\\u0026#34;, new Type[] { realPropertyType }, new Expression[] { constantParam, propertyParam })); } return null; } private static Expression GetGroupExpression (ParameterExpression parameter, List\\u0026lt;Condition\\u0026gt; orConditions) { if (orConditions.Count == 0) return null; var exps = orConditions.Select (c =\\u0026gt; GetExpression (parameter, c)).ToList (); return exps.Aggregate\\u0026lt;Expression, Expression\\u0026gt; (null, (left, right) =\\u0026gt; { if (left == null) return right; return Expression.OrElse (left, right); }); } public static Expression\\u0026lt;Func\\u0026lt;T, bool\\u0026gt;\\u0026gt; BuildLambda\\u0026lt;T\\u0026gt; (IEnumerable\\u0026lt;Condition\\u0026gt; conditions) { if (conditions == null || !conditions.Any ()) return x =\\u0026gt; true; var parameter = Expression.Parameter (typeof (T), \\u0026#34;x\\u0026#34;); //简单条件 var simpleExps = conditions.ToList ().FindAll (c =\\u0026gt; string.IsNullOrEmpty (c.OrGroup)) .Select (c =\\u0026gt; GetExpression (parameter, c)) .ToList (); //复杂条件 var complexExps = conditions.ToList ().FindAll (c =\\u0026gt; !string.IsNullOrEmpty (c.OrGroup)) .GroupBy (x =\\u0026gt; x.OrGroup) .Select (g =\\u0026gt; GetGroupExpression (parameter, g.ToList ())) .ToList (); var exp = simpleExps.Concat (complexExps).Aggregate\\u0026lt;Expression, Expression\\u0026gt; (null, (left, right) =\\u0026gt; { if (left == null) return right; return Expression.AndAlso (left, right); });; return Expression.Lambda\\u0026lt;Func\\u0026lt;T, bool\\u0026gt;\\u0026gt; (exp, parameter); } } 接下来，我们就可以以一种优雅的方式来对编写查询条件：\\nvar searchParameters = new SearchParameters(); searchParameters.Query = new QueryModel(); searchParameters.Query.Add(new Condition() { Field = \\u0026#34;IntValue\\u0026#34;, Op = Operation.LessThan, Value = 30 }); searchParameters.Query.Add(new Condition() { Field = \\u0026#34;StringValue\\u0026#34;, Op = Operation.Contains, Value = \\u0026#34;山\\u0026#34;, OrGroup = \\u0026#34;StringValue\\u0026#34; }); searchParameters.Query.Add(new Condition\\u0026lt;Foo\\u0026gt;() { Field = x =\\u0026gt; x.StringValue, Op = Operation.Contains, Value = \\u0026#34;有朋\\u0026#34;, OrGroup = \\u0026#34;StringValue\\u0026#34; }); var lambda = LambdaExpressionBuilder.BuildLambda\\u0026lt;Foo\\u0026gt;(searchParameters.Query); var where = lambda.Compile(); var result = list.Where(where); 这种实现可以说相当巧妙啦，因为通过有限的条件，我们就可以覆盖到大部分查询的场景，而如果直接去解析一个 Lambda 表达式，难度显然会增加不少。这里是以一个普通的泛型列表作为示例的，而在实际使用中，常常是结合 EntityFramework 这类 ORM 来使用的。相应地，我们只需要为 IQueryable 接口扩展出支持 SearchParameter 作为参数进行查询地扩展方法即可，这分别对应了我们在文章一开头所提到的IEnumerable\\u0026lt;T\\u0026gt;和IQueryable \\u0026lt;T\\u0026gt;。\\n可如果遇上 Dapper 这样的轻量级 ORM，我们要考虑的问题就变成了怎么通过 Lambda 表达式生成 SQL 语句，所以，通过 Dapper 来扩展功能的时候，最困难的地方，往往在于没法儿像 EF/EF Core 一样去随心所欲地 Where()，像 Dapper.Contrib 则只能先查询出所有结果再去做进一步的过滤，这种在数据量特别大的时候就会出问题。通过 Lambda 生成 SQL，最难的地方是，你压根不知道，人家会写一个什么样的表达式，而这个表达式，又怎么通过 SQL 去表达。那么，退而求其次，我们继续用 SearchParameters 来实现，因为它里面的 QueryMethod 是有限的，下面给出一个简单的实现：\\npublic static class SearchParametersExtension { public static (string, Dictionary\\u0026lt;string, object\\u0026gt;) BuildSqlWhere (this SearchParameters searchParameters) { var conditions = searchParameters.Query; if (conditions == null || !conditions.Any ()) return (string.Empty, null); var sqlExps = new List\\u0026lt;string\\u0026gt; (); var sqlParam = new Dictionary\\u0026lt;string, object\\u0026gt; (); //构建简单条件 var simpleConditions = conditions.FindAll (x =\\u0026gt; string.IsNullOrEmpty (x.OrGroup)); sqlExps.Add (simpleConditions.BuildSqlWhere (ref sqlParam)); //构建复杂条件 var complexConditions = conditions.FindAll (x =\\u0026gt; !string.IsNullOrEmpty (x.OrGroup)); sqlExps.AddRange (complexConditions.GroupBy (x =\\u0026gt; x.OrGroup).ToList ().Select (x =\\u0026gt; \\u0026#34;( \\u0026#34; + x.BuildSqlWhere (ref sqlParam, \\u0026#34; OR \\u0026#34;) + \\u0026#34; )\\u0026#34;)); var sqlWhwere = sqlExps.Count \\u0026gt; 1 ? string.Join (\\u0026#34; AND \\u0026#34;, sqlExps) : sqlExps[0]; return ($\\u0026#34; WHERE {sqlWhwere} \\u0026#34;, sqlParam); } public static string BuildSqlWhere (this IEnumerable\\u0026lt;Condition\\u0026gt; conditions, ref Dictionary\\u0026lt;string, object\\u0026gt; sqlParams, string keywords = \\u0026#34; AND \\u0026#34;) { if (conditions == null || !conditions.Any ()) return string.Empty; var sqlParamIndex = 1; var sqlExps = new List\\u0026lt;string\\u0026gt; (); foreach (var condition in conditions) { var index = sqlParams.Count + sqlParamIndex; switch (condition.Op) { case Operation.Equals: sqlExps.Add ($\\u0026#34;{condition.Field} = @Param{index}\\u0026#34;); sqlParams[$\\u0026#34;Param{index}\\u0026#34;] = condition.Value; break; case Operation.NotEquals: sqlExps.Add ($\\u0026#34;{condition.Field} \\u0026lt;\\u0026gt; @Param{index}\\u0026#34;); sqlParams[$\\u0026#34;Param{index}\\u0026#34;] = condition.Value; break; case Operation.Contains: sqlExps.Add ($\\u0026#34;{condition.Field} LIKE @Param{index}\\u0026#34;); sqlParams[$\\u0026#34;Param{index}\\u0026#34;] = $\\u0026#34;%{condition.Value}%\\u0026#34;; break; case Operation.NotContains: sqlExps.Add ($\\u0026#34;{condition.Field} NOT LIKE @Param{index}\\u0026#34;); sqlParams[$\\u0026#34;Param{index}\\u0026#34;] = $\\u0026#34;%{condition.Value}%\\u0026#34;; break; case Operation.StartsWith: sqlExps.Add ($\\u0026#34;{condition.Field} LIKE @Param{index}\\u0026#34;); sqlParams[$\\u0026#34;Param{index}\\u0026#34;] = $\\u0026#34;%{condition.Value}\\u0026#34;; break; case Operation.EndsWith: sqlExps.Add ($\\u0026#34;{condition.Field} LIKE @Param{index}\\u0026#34;); sqlParams[$\\u0026#34;Param{index}\\u0026#34;] = $\\u0026#34;{condition.Value}%\\u0026#34;; break; case Operation.GreaterThen: sqlExps.Add ($\\u0026#34;{condition.Field} \\u0026gt; @Param{index}\\u0026#34;); sqlParams[$\\u0026#34;Param{index}\\u0026#34;] = $\\u0026#34;{condition.Value}\\u0026#34;; break; case Operation.GreaterThenOrEquals: sqlExps.Add ($\\u0026#34;{condition.Field} \\u0026gt;= @Param{index}\\u0026#34;); sqlParams[$\\u0026#34;Param{index}\\u0026#34;] = $\\u0026#34;{condition.Value}\\u0026#34;; break; case Operation.LessThan: sqlExps.Add ($\\u0026#34;{condition.Field} \\u0026lt; @Param{index}\\u0026#34;); sqlParams[$\\u0026#34;Param{index}\\u0026#34;] = $\\u0026#34;{condition.Value}\\u0026#34;; break; case Operation.LessThanOrEquals: sqlExps.Add ($\\u0026#34;{condition.Field} \\u0026lt;= @Param{index}\\u0026#34;); sqlParams[$\\u0026#34;Param{index}\\u0026#34;] = $\\u0026#34;{condition.Value}\\u0026#34;; break; case Operation.StdIn: sqlExps.Add ($\\u0026#34;{condition.Field} IN @Param{index}\\u0026#34;); sqlParams[$\\u0026#34;Param{index}\\u0026#34;] = $\\u0026#34;{condition.Value}\\u0026#34;; break; case Operation.StdNotIn: sqlExps.Add ($\\u0026#34;{condition.Field} NOT IN @Param{index}\\u0026#34;); sqlParams[$\\u0026#34;Param{index}\\u0026#34;] = $\\u0026#34;{condition.Value}\\u0026#34;; break; } sqlParamIndex += 1; } return sqlExps.Count \\u0026gt; 1 ? string.Join (keywords, sqlExps) : sqlExps[0]; } } 现在，我们可以换一种方式来查 Dapper，果然是因为手写 SQL 没有安全感的缘故啊！\\nvar searchParameters = new SearchParameters(); searchParameters.Page = new PageModel() { PageSize = 10, CurrentPage = 1 }; searchParameters.Query = new QueryModel(); searchParameters.Query.Add(new Condition() { Field = \\u0026#34;OrgCode\\u0026#34;, Op = Operation.Contains, Value = \\u0026#34;飞天御剑流\\u0026#34;, OrGroup = \\u0026#34;OrgCode\\u0026#34; }); searchParameters.Query.Add(new Condition() { Field = \\u0026#34;OrgCode\\u0026#34;, Op = Operation.Equals, Value = \\u0026#34;新选组\\u0026#34;, OrGroup = \\u0026#34;OrgCode\\u0026#34; }); searchParameters.Query.Add(new Condition() { Field = \\u0026#34;CreatedAt\\u0026#34;, Op = Operation.GreaterThenOrEquals, Value = new DateTime(2020, 1, 1)}); _repository.GetByQuery\\u0026lt;BusinessUnit\\u0026gt;(searchParameters); 对于定义Condition时，Field属性安全感缺失的问题，我们可以这样来解决：\\npublic class Condition\\u0026lt;T\\u0026gt; : Condition public new Expression\\u0026lt;Func\\u0026lt;T, dynamic\\u0026gt;\\u0026gt; Field { get; set; } public Operation Op { get; set; } public object Value { get; set; } public string OrGroup { get; set; } } public class QueryModel : List\\u0026lt;Condition\\u0026gt; { public void Add\\u0026lt;T\\u0026gt;(Condition\\u0026lt;T\\u0026gt; condition) where T : class { var filedName = string.Empty; var memberExp = condition.Field.Body as MemberExpression; if (memberExp == null) { var ubody = (UnaryExpression)condition.Field.Body; memberExp = ubody.Operand as MemberExpression; } filedName = memberExp.Member.Name; Add(new Condition() { Field = filedName, Op = condition.Op, Value = condition.Value, OrGroup = condition.OrGroup }); } } 其实，这还是表达式树的内容，在上面的代码片段中，早已出现过它的身影，回想起多年前用这个东西改造 INotifyPropertyChanged 的时候，总觉得一切似曾相识：\\nsearchParameters.Query.Add(new Condition\\u0026lt;Foo\\u0026gt;() { Field = x =\\u0026gt; x.StringValue, Op = Operation.Contains, Value = \\u0026#34;有朋\\u0026#34;, OrGroup = \\u0026#34;StringValue\\u0026#34; }); 本文小结 和博主的大多数博客一样，这篇博客是一个“醉翁之意不在酒”的博客。听起来在说如何动态创建 Lambda 表达式，实际上讲的还是表达式树，至于原因，则还是博客开篇所提到的“一以贯之”。博主想写这篇博客，是源于实际工作中遇到的“查询”问题，而最后解决的还真就是查询的问题。不管是 Dynamic Linq 中的 ParseLambda()还是表达式树中的 LambdaExpression，本质上都是同一个东西，最终的命运都是 Predict这个委托。SearchParameters 则是对前者的一种简化，通过控制 Lambda 表达式的复杂度来简化问题，相比起直接传一个字符串过来，这种在风险的控制上要更高一点，之所以要传字符串，则是又一个非关技术的无聊的问题了，用 Jira 里的概念说应该叫做设计如此(By Design)。好了，以上就是这篇博客的内容啦，谢谢大家！\\n\"",
            "url": "\"/posts/118272597/\"",
            "date": "\"2020-05-08\""
        },
        
        {
            "title": "\"从 .NET Core 2.2 升级到 3.1 的踩坑之旅\"",
            "content": "\"有时候，版本更新太快并不是一件好事。虽然，两周一个迭代的“敏捷”开发依然被客户嫌弃交付缓慢，可一边是前端领域“求不要再更新了，学不动了”的声音，一边则是.NET Core从1.x到2.x再到3.x的高歌猛进。版本更新太快，带来的是API的频繁变动，无法形成有效的知识沉淀，就像转眼到了2020年，Python 2.x和Windows 7都引来了“寿终正寝”，可能你都还没有认真地学习过这些知识，突然就被告知这些知识要过期了，想想还是觉得挺疯狂啊。最近一直在捣鼓，如何让.NET Core应用跑在Heroku平台上，因为Docker镜像里使用最新的.NET Core 3.1运行时，所以，痛定思痛之余，决定把手头项目升级到3.1。上一次痛苦还是在2.1升级2.2，这还真没过多长时间。所以呢，这篇博客主要梳理下从2.2升级到3.1过程中遇到的问题。\\n更新项目文件 调整目标框架为netcoreapp3.1 删除引用项：Microsoft.AspNetCore.App、Microsoft.AspNetCore.Razor.Design 删除AspNetCoreHostingModel，如果项目文件中的值为InProcess(因为ASP.NET Core 3.0 或更高版本项目默认为进程内承载模型） 更新程序入口 CreateWebHostBuilder()方法的返回值类型由IWebHostBuilder调整为IHostBuilder 增加引用项：Microsoft.Extensions.Hosting Kestrel配置变更至ConfigureWebHostDefaults()方法 public static IHostBuilder CreateWebHostBuilder(string[] args) =\\u0026gt;\\rHost.CreateDefaultBuilder(args)\\r.ConfigureWebHostDefaults(webBuilder =\\u0026gt;\\r{\\rwebBuilder.ConfigureKestrel(serverOptions =\\u0026gt;\\r{\\r// Set properties and call methods on options\\r})\\r.UseStartup\\u0026lt;Startup\\u0026gt;();\\r}); 如果通过 HostBuilder手动创建宿主，则需要在 ConfigureWebHostDefaults()方法中显式调用·UseKestrel()：\\npublic static void Main (string[] args) {\\rvar host = new HostBuilder ()\\r.UseContentRoot (Directory.GetCurrentDirectory ())\\r.ConfigureWebHostDefaults (webBuilder =\\u0026gt; {\\rwebBuilder.UseKestrel (serverOptions =\\u0026gt; {\\r// Set properties and call methods on options\\r})\\r.UseIISIntegration ()\\r.UseStartup\\u0026lt;Startup\\u0026gt; ();\\r})\\r.Build ();\\rhost.Run ();\\r} 更新Startup Configure()方法第二个参数由``IHostingEnvironment调整为IWebHostEnvironment(需要引用Microsoft.Extensions.Hosting`) 从管道中删除UseMvc()扩展方法，相应地，删除AddMvc()及其链式调用相关方法 AddMvc()等价于AddRazorPages() + AddControllersWithViews() AddControllers()对应WebApi模板，AddControllersWithViews()对应MVC模板， AddRazorPages()对应SPA模板 路由注册由传统路由调整为终结点路由： public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\\r{\\rapp.UseStaticFiles();\\rapp.UseRouting();\\rapp.UseCors();\\rapp.UseAuthentication();\\rapp.UseAuthorization();\\rapp.UseEndpoints(endpoints =\\u0026gt;\\r{\\r//SignalR路由 endpoints.MapHub\\u0026lt;ChatHub\\u0026gt;(\\u0026#34;/chat\\u0026#34;);\\r//RazorPages路由\\rendpoints.MapRazorPages()\\r//特性路由(WebApi)\\rendpoints.MapControllers();\\r//控制器路由(MVC)\\rendpoints.MapControllerRoute(\\u0026#34;default\\u0026#34;, \\u0026#34;{controller=Home}/{action=Index}/{id?}\\u0026#34;);\\r});\\r} 如果希望继续使用传统路由，则可以使用下列方法任一：\\nservices.AddMvc(options =\\u0026gt; options.EnableEndpointRouting = false);\\rservices.AddControllers(options =\\u0026gt; options.EnableEndpointRouting = false);\\rservices.AddControllersWithViews(options =\\u0026gt; options.EnableEndpointRouting = false);\\rservices.AddRazorPages().AddMvcOptions(options =\\u0026gt; options.EnableEndpointRouting = false); 序列化/反序列化 从.NET Core 3.0 开始，System.Text.Json默认作为替代Newtonsoft.json的新一代JSON API 直接从.NET Core 3.0 创建的SignalR项目，服务端返回的JSON数据存在大小写的问题，这是由System.Text.Json引起的。解决方案是： services.AddSignalR()\\r.AddJsonProtocol(options =\\u0026gt; options.PayloadSerializerOptions.PropertyNamingPolicy = null); 同理，对于该方案对于services.AddControllers()一样有效，前提是项目中使用了System.Text.Json。同理，对于SignalR的客户端项目，我们有：\\nnew HubConnectionBuilder()\\r.WithUrl(\\u0026#34;/chatHub\\u0026#34;)\\r.AddJsonProtocol(options =\\u0026gt;\\r{ //TODO\\r})\\r.Build(); SignalR的JavaScript客户端由@aspnet/signalr 调整为为 @microsoft/signalr： const signalR = require(\\u0026#34;@microsoft/signalr\\u0026#34;);\\rlet connection = new signalR.HubConnectionBuilder().withUrl(url).build(); 如果希望继续使用Newtonsoft.json，则需要安装AspNetCore NewtonsoftJson。相应地，需要显式调用AddNewtonsoftJson()扩展方法： services.AddControllers()\\r.AddNewtonsoftJson(options =\\u0026gt; {\\roptions.SerializerSettings.ContractResolver = new CamelCasePropertyNamesContractResolver();\\r}); 同样地，AddNewtonsoftJson()支持AddControllers()， AddControllersWithViews()， AddRazorPages()所有方法\\n疑难杂症 升级后提示无法加载类型：Microsoft.AspNetCore.Mvc.MvcJsonOptions，解决方案是： 升级Swashbuckle.AspNetCore至最新版本(5.0+)，调整Swagger中间件配置代码： services.AddSwaggerGen(swagger =\\u0026gt;\\r{\\r//这里发生了变化，需要引用：Microsoft.OpenApi.Models\\rswagger.SwaggerDoc(\\u0026#34;v1\\u0026#34;, new OpenApiInfo { Title = \\u0026#34;ynamic WebApi\\u0026#34;, Version = \\u0026#34;v1.0\\u0026#34; });\\r}); 安装完 .NET Core 3.x，使用dotnet build编译项目提示找不到Microsoft.NET.Sdk.Web。解决方案是： 升级2.2的时候，调整项目文件中的Microsoft.NET.Sdk.Web为Microsoft.NET.Sdk可以解决，而这个方法在3.x以后失效。 此时，可以检查环境变量MSBuildSDKsPath中的SDK版本和实际版本是否一致，尤其是像博主这样从2.0一路升级到3.x的朋友，应该都会遇到这个问题。 参考链接 从 ASP.NET Core 2.2 迁移到3.0 升级 ASP.NET Core 3.0 设置 JSON 返回 PascalCase 格式与 SignalR 问题 Incompatibility with ASP.NET Core 3.0 \"",
            "url": "\"/posts/3099575458/\"",
            "date": "\"2020-01-22\""
        },
        
        {
            "title": "\"使用 ASP.NET Core 和 Hangfire 实现 HTTP 异步化方案\"",
            "content": "\"Hi，大家好，我是 Payne，欢迎大家一如既往地关注我的博客。今天这篇博客里的故事背景，来自我工作中的一次业务对接，因为客户方提供的是长达上百行的 XML，所以一度让更喜欢使用 JSON 的博主感到沮丧，我这里不是想讨论 XML 和 JSON 彼此的优缺点，而是我不明白 AJAX 里的 X 现在基本都被 JSON 替代了，为什么还有这么多的人坚持使用并友好的 XML 作为数据的交换协议呢？也许你会说，因为有这样或者那样等等的理由，就像 SOA、ESB、SAP 等等类似的技术在企业级用户依然大量流行一样，而这些正是“消费”XML 的主力军。我真正想说的是，在对接这类接口时，我们会遇到一个异步化的 HTTP 协议场景，这里的异步和多线程、async/await 没有直接关系，因为它描述的实际上是业务流程上的一种“异步”。\\n引子-想对 XML 说不 我们知道，HTTP 协议是一个典型的请求-响应模型，由调用方(Client)调用服务提供者(Server)提供的接口，在理想状态下，后者在处理完请求后会直接返回结果。可是当后者面对的是一个“耗时”任务时，这种方式的问题就立马凸显出来，此时调用者有两个选择：一直等对方返回直至超时(同步)、隔一会儿就看看对方是否处理完了(轮询)。这两种方式，相信大家都非常熟悉了，如果继续延伸下去，我们会联想到长/短轮询、SignalR、WebSocket。其实，更好的方式是，我们接收到一个“耗时”任务时，立即返回表明我们接收了任务，等任务执行完以后再通知调用者，这就是我们今天要说的 HTTP 异步化方案。因为对接过程中，客户采用的就是这种方案，ESB 这类消息总线本身就提供了这种功能，可作为调用方的博主就非常难受啦，因为明明能“同步”地处理完的事情，现在全部要变成“异步”处理，就像一个习惯了 async/await 语法糖的人，突然间就要重新开始写 APM 风格的代码，宝宝心里苦啊，“异步”处理就异步处理嘛，可要按人家要求去返回上百行的 XML，博主表示想死的心都有了好嘛……\\n好了，吐槽归吐槽，吐槽完我们继续梳理下 HTTP 异步化的方案，这种方式在现实生活中还是相当普遍的，毕竟人类都是“异步”做事，譬如“等你哪天有空一起吃个饭”，测试同事对我说得最多的话就是，“等你这个 Bug 改完了同我说一声”，更不用说，JavaScript 里典型的异步单线程的应用等等……实现“异步”的思路其实是非常多的，比如同样在 JavaScript 里流行的回调函数，比如通过一张中间表存起来，比如推送消息到消息队列里。在面向数据库编程的时候，我听到最多的话就是，没有什么问题是不能用一张中间表来解决的，如果一张不行那就用两张。项目上我是用 Quartz+中间表的方式实现的，因为这是最为普通的方式。这里，我想和大家分享下，关于使用 Hangfire 来实现类似 Quartz 定时任务的相关内容，果然，我这次又做了一次标题党呢，希望大家会对今天的内容感兴趣。简单来说，我们会提供一个接口，调用方提供参数和回调地址，调用后通过 Hangfire 创建后台任务，等任务处理结束后，再通过回调地址返回结果给调用方，这就是所谓的 HTTP 异步化。\\n开箱即用的 Hangfire 我们项目上是使用 Quartz 来实现后台任务的，因为它采用了反射的方式来调用具体的 Job，因此，它的任务调度和任务实现是耦合在同一个项目里的，常常出现单个 Job 引发整个系统卡顿的情况，尤其是是它的触发器，常常导致一个 Job 停都停不下来，直到后来才渐渐开始通过 Web API 来分离这两个部分。Quartz 几乎没有一个自己的可视化界面，我们为此专门为它开发了一套 UI。我这里要介绍的 Hangfire，可以说它刚好可以作为 Quartz 的替代品，它是一个开箱即用的、轻量级的、开源后台任务系统，想想以前为 Windows 开发定时任务，只能通过定时器(Timer)来实现，尚不知道 CRON 为何物，而且只能用命令行那种拙劣的方式来安装/卸载，我至今都记得，测试同事问我，能不能不要每次都弹个黑窗口出来，这一起想起来还真是让人感慨啊。好了，下面我们开始今天的实践吧！首先，第一步自然是安装 Hangfire 啦，这里我们新建一个 ASP.NET Core 的 Web API 项目就好，然后通过 NuGet 依次安装以下库：\\nInstall-Package HangFire Install-Package Hangfire.MySql.Core 这里我们选择了 MySQL 来实现任务的持久化，从官方的流程图中可以了解到，Hangfire 有服务端、持久化存储和客户端三大核心部件组成，而持久化存储这块儿，除了官方默认的 SQLServer(可以集成 MSMQ)以外，还支持 Redis、MongoDB 等，Hangfire 使用起来是非常简单哒，首先在 Startup 类的 ConfigureServices()方法中注入 Hangfire 相关的服务，然后在 Configure()方法中使用 HangfireServer 和 UseHangfireDashboard 即可：\\npublic void ConfigureServices (IServiceCollection services) { //为了简化说明，已忽略该方法中无关的代码 services.AddHangfire (x =\\u0026gt; x.UseStorage (new MySqlStorage (Configuration.GetConnectionString (\\u0026#34;Hangfire\\u0026#34;))) .UseFilter (new HttpJobFilter ()) .UseSerilogLogProvider () ); } public void Configure (IApplicationBuilder app, IHostingEnvironment env) { //为了简化说明，已忽略该方法中无关的代码 app.UseHangfireServer (new BackgroundJobServerOptions () { Queues = new string[] { \\u0026#34;default\\u0026#34; }, WorkerCount = 5, ServerName = \\u0026#34;default\\u0026#34;, }); app.UseHangfireDashboard (); app.ApplicationServices.GetService\\u0026lt;ILoggerFactory\\u0026gt; ().AddSerilog (); } 注意到在配置持久化的部分，我们使用了一个数据库连接字符串 Hangfire，它需要我们在 appsettings.json 中配置 ConnectionStrings 部分。这里我们为 Hangfire 设置了默认队列 default、默认服务器 default、并发数目为 5。与此同时，我们开启了 Hangfire 中自带的 Dashboard，可以通过这个界面来监控后台任务的执行情况。此时运行项目，输入以下地址：http://locahost:/hangfire，就会看到下面的画面，这说明 Hangfire 配置成功：\\nHangfire 中默认支持四种类型的后台任务，他们分别是Fire-and-forget jobs、Delayed jobs、Recurring jobs和Continuations。严格来说，Fire-and-forget jobs和Delayed jobs并不能算后台任务，因为它们在执行一次后就会从队列中移除，属于一次性“消费”的任务，这两者的不同在于Delayed jobs可以在设定的时间上延迟执行。而Recurring jobs和Continuations则是周期性任务，任务在入队后可以按照固定的时间间隔去执行，周期性任务都是支持 CRON 表达式的，Continuations类似于 Task 中的 ContinueWith()方法，可以对多个任务进行组合，我们现在的项目中开发了大量基于 Quartz 的 Job，可当你试图把这些 Job 相互组合起来的时候，你就会觉得相当尴尬，因为后台任务做所的事情往往都是大同小异的。从官方文档中 ，我们会发现 Hangfire 的关键代码只有下面这四行代码，可以说是相当简洁啦！\\n//Fire-and-forget jobs var jobId = BackgroundJob.Enqueue( () =\\u0026gt; Console.WriteLine(\\u0026#34;Fire-and-forget!\\u0026#34;)); //Delayed jobs var jobId = BackgroundJob.Schedule( () =\\u0026gt; Console.WriteLine(\\u0026#34;Delayed!\\u0026#34;), TimeSpan.FromDays(7)); //Recurring jobs RecurringJob.AddOrUpdate( () =\\u0026gt; Console.WriteLine(\\u0026#34;Recurring!\\u0026#34;), Cron.Daily); //Continuations BackgroundJob.ContinueWith( jobId, () =\\u0026gt; Console.WriteLine(\\u0026#34;Continuation!\\u0026#34;)); Hangfire 除了这种偏函数式风格的用法以外，同样提供了泛型版本的用法，简而言之，泛型版本是自带依赖注入的版本。众所周知，稍微复杂点的功能，常常会依赖多个服务，比如后台任务常常需要给相关人员发邮件或者是消息，此时，Job 的实现就会依赖 MailService 和 MessageService。Hangfire 内置了基于 Autofac 的 IoC 容器，因此，当我们使用泛型版本时，它可以自动地从容器中 Resolve 相应的类型出来。事实上，我们可以通过重写 JobActivator 来实现自己的依赖注入，譬如博主就喜欢 Castle。下面是一个简单的例子：\\n//Define a class depends on IDbContext \\u0026amp; IEmailService public class EmailSender { private IDbContext _dbContext; private IEmailService _emailService; public EmailSender() { _dbContext = new DbContext(); _emailService = new EmailService(); } // ... } //When it is registered in Ioc Container BackgroundJob.Enqueue\\u0026lt;EmailSender\\u0026gt;(x =\\u0026gt; x.Send(\\u0026#34;Joe\\u0026#34;, \\u0026#34;Hello!\\u0026#34;)); 可扩展的 Hangfire OK，在对 Hangfire 有了一个初步的了解以后，我们再回到本文的题目，我们希望实现一个基于 HTTP 方式调用的 HttpJob。因为我们不希望任务调度和具体任务放在一起，我们项目上采用 Quartz 来开发后台任务，它要求我们实现一个特定接口 IbaseJob，最终任务调度时会通过反射来创建 Job，就在刚刚过去的这周里，测试同事向我反馈了一个 Bug，而罪魁祸首居然是因为某个 DLL 没有分发，所以，我希望实现一个基于 HTTP 方式调用的 HttpJob，这既是为了将任务调度和具体任务分离，同时为了满足这篇文章开头描述的场景，得益于 Hnagfire 良好的扩展性，我们提供了一组 Web API，代码如下：\\n/// \\u0026lt;summary\\u0026gt; /// 添加一个任务到队列并立即执行 /// \\u0026lt;/summary\\u0026gt; /// \\u0026lt;param name=\\u0026#34;jobDescriptor\\u0026#34;\\u0026gt;\\u0026lt;/param\\u0026gt; /// \\u0026lt;returns\\u0026gt;\\u0026lt;/returns\\u0026gt; [HttpPost (\\u0026#34;AddEnqueue\\u0026#34;)] public JsonResult Enqueue (HttpJobDescriptor jobDescriptor) { try { var jobId = string.Empty; jobId = BackgroundJob.Enqueue (() =\\u0026gt; HttpJobExecutor.DoRequest (jobDescriptor)); return new JsonResult (new { Flag = true, Message = $\\u0026#34;Job:#{jobId}-{jobDescriptor.JobName}已加入队列\\u0026#34; }); } catch (Exception ex) { return new JsonResult (new { Flag = false, Message = ex.Message }); } } /// \\u0026lt;summary\\u0026gt; /// 添加一个延迟任务到队列 /// \\u0026lt;/summary\\u0026gt; /// \\u0026lt;param name=\\u0026#34;jobDescriptor\\u0026#34;\\u0026gt;\\u0026lt;/param\\u0026gt; /// \\u0026lt;returns\\u0026gt;\\u0026lt;/returns\\u0026gt; [HttpPost (\\u0026#34;AddSchedule\\u0026#34;)] public JsonResult Schedule ([FromBody] HttpJobDescriptor jobDescriptor) { try { var jobId = string.Empty; jobId = BackgroundJob.Schedule (() =\\u0026gt; HttpJobExecutor.DoRequest (jobDescriptor), TimeSpan.FromMinutes ((double) jobDescriptor.DelayInMinute)); return new JsonResult (new { Flag = true, Message = $\\u0026#34;Job:#{jobId}-{jobDescriptor.JobName}已加入队列\\u0026#34; }); } catch (Exception ex) { return new JsonResult (new { Flag = false, Message = ex.Message }); } } /// \\u0026lt;summary\\u0026gt; /// 添加一个定时任务 /// \\u0026lt;/summary\\u0026gt; /// \\u0026lt;param name=\\u0026#34;jobDestriptor\\u0026#34;\\u0026gt;\\u0026lt;/param\\u0026gt; /// \\u0026lt;returns\\u0026gt;\\u0026lt;/returns\\u0026gt; [HttpPost (\\u0026#34;AddRecurring\\u0026#34;)] public JsonResult Recurring ([FromBody] HttpJobDescriptor jobDescriptor) { try { var jobId = string.Empty; RecurringJob.AddOrUpdate (jobDescriptor.JobName, () =\\u0026gt; HttpJobExecutor.DoRequest (jobDescriptor), jobDescriptor.Corn, TimeZoneInfo.Local); return new JsonResult (new { Flag = true, Message = $\\u0026#34;Job:{jobDescriptor.JobName}已加入队列\\u0026#34; }); } catch (Exception ex) { return new JsonResult (new { Flag = false, Message = ex.Message }); } } /// \\u0026lt;summary\\u0026gt; /// 删除一个定时任务 /// \\u0026lt;/summary\\u0026gt; /// \\u0026lt;param name=\\u0026#34;jobName\\u0026#34;\\u0026gt;\\u0026lt;/param\\u0026gt; /// \\u0026lt;returns\\u0026gt;\\u0026lt;/returns\\u0026gt; [HttpDelete (\\u0026#34;DeleteRecurring\\u0026#34;)] public JsonResult Delete (string jobName) { try { RecurringJob.RemoveIfExists (jobName); return new JsonResult (new { Flag = true, Message = $\\u0026#34;Job:{jobName}已删除\\u0026#34; }); } catch (Exception ex) { return new JsonResult (new { Flag = false, Message = ex.Message }); } } /// \\u0026lt;summary\\u0026gt; /// 触发一个定时任务 /// \\u0026lt;/summary\\u0026gt; /// \\u0026lt;param name=\\u0026#34;jobName\\u0026#34;\\u0026gt;\\u0026lt;/param\\u0026gt; /// \\u0026lt;returns\\u0026gt;\\u0026lt;/returns\\u0026gt; [HttpGet (\\u0026#34;TriggerRecurring\\u0026#34;)] public JsonResult Trigger (string jobName) { try { RecurringJob.Trigger (jobName); return new JsonResult (new { Flag = true, Message = $\\u0026#34;Job:{jobName}已触发执行\\u0026#34; }); } catch (Exception ex) { return new JsonResult (new { Flag = false, Message = ex.Message }); } } /// \\u0026lt;summary\\u0026gt; /// 健康检查 /// \\u0026lt;/summary\\u0026gt; /// \\u0026lt;returns\\u0026gt;\\u0026lt;/returns\\u0026gt; [HttpGet (\\u0026#34;HealthCheck\\u0026#34;)] public IActionResult HealthCheck () { var serviceUrl = Request.Host; return new JsonResult (new { Flag = true, Message = \\u0026#34;All is Well!\\u0026#34;, ServiceUrl = serviceUrl, CurrentTime = DateTime.Now }); } 你可以注意到，这里用到其实还是四种后台任务，在此基础上增加了删除 Job 和触发 Job 的接口，尤其是触发 Job 执行的接口，可以弥补 Quartz 的不足，很多时候，我们希望别人调了接口后触发后台任务，甚至希望在编写 Job 的过程中使用依赖注入，因为种种原因，实施起来总感觉有点碍手碍脚。这里我们定义了一个 HttpJobExecutor 的类，顾名思义，它是执行 Http 请求的一个类，说来惭愧，我写作这篇博客时，是一边看文档一边写代码的，所以，等我实现了这里的 HttpJobExecutor 的时候，我忽然发现文档中关于依赖注入的内容，简直相见恨晚啊。这里直接给出它的实现，我要再一次安利 RestSharp 这个库，比 HttpWebRequest、HttpClient 这两套官方的 API 要好用许多，可还是有人喜欢一遍又一遍地封装啊，话说自从我们把 WCF 换成 Web API 后，看着相关同事在 Git 上的折腾历史，果然还是回到了写 Http Client 的老路上来，话说在纠结是手写代理还是动态代理的时候，Retrofit 了解下啊！\\n[HttpJobFilter] public static void DoRequest (HttpJobDescriptor jobDestriptor) { var client = new RestClient (jobDestriptor.HttpUrl); var httpMethod = (object) Method.POST; if (!Enum.TryParse (typeof (Method), jobDestriptor.HttpMethod.ToUpper (), out httpMethod)) throw new Exception ($\\u0026#34;不支持的HTTP动词：{jobDestriptor.HttpMethod}\\u0026#34;); var request = new RestRequest ((Method) httpMethod); if (jobDestriptor.JobParameter != null) { var json = JsonConvert.SerializeObject (jobDestriptor.JobParameter); request.AddParameter (\\u0026#34;application/json\\u0026#34;, json, ParameterType.RequestBody); } var response = client.Execute (request); if (response.StatusCode != HttpStatusCode.OK) throw new Exception ($\\u0026#34;调用接口{jobDestriptor.HttpUrl}失败，接口返回：{response.Content}\\u0026#34;); } 在这里，我们以 HealthCheck 这个接口为例，来展示 HttpJob 是如何工作的。顾名思义，这是一个负责健康检查的接口。我们现在通过 Postman 来触发健康检查这个后台任务。在这里，该接口是一个 GET 请求：\\n接下来，我们我们就会在 Hangfire 的 Dashborad 中找到对应的记录，因为这是一个Fire \\u0026amp; Forget类型的任务，因此我们几乎看不到中间的过程，它就已经执行结束啦。我们可以在 Dashboard 中找到对应的任务，然后了解它的具体执行情况。值得一提的是，Hangfire 自带了重试机制，对于执行失败的任务，我们可以重试栏目下看到，这里是其中一条任务的执行记录。可以注意到，Hangfire 会把每个 Job 的参数序列化为 JSON 并持久化起来，仔细对照的话，你会发现，它和我们在 Postman 中传入的参数是完全一样的！\\n在执行 Job 的过程中，我们可能会希望记录 Job 执行过程中的日志。这个时候，Hangfire 强大的扩展性再次我们提供了这种可能性。注意到在 HttpJobExecutor 类上有一个 [HttpJobFilter]的标记，显然这是由 Hangfire 提供的一个过滤器，博主在这个过滤器中对 Job 的 ID、状态等做了记录，因为在整个项目中博主已经配置了 Serilog 作为 Hangfire 的 LogProvider，所以，我们可以在过滤器中使用 Serilog 来记录日志，不过博主个人感觉这个 Filtre 稍显鸡肋，这里还是给出代码片段吧！\\npublic class HttpJobFilter : JobFilterAttribute, IApplyStateFilter { private static readonly ILog Logger = LogProvider.GetCurrentClassLogger (); public void OnStateApplied (ApplyStateContext context, IWriteOnlyTransaction transaction) { if (context.NewState is FailedState) { var failedState = context.NewState as FailedState; if (failedState != null) { Logger.ErrorException ( String.Format (\\u0026#34;Background Job #{0} 执行失败。\\u0026#34;, context.BackgroundJob.Id), failedState.Exception); } } else { Logger.InfoFormat ( \\u0026#34;当前执行的Job为：#{0}, 状态为：{1}。\\u0026#34;, context.BackgroundJob.Id, context.NewState.Name ); } } public void OnStateUnapplied (ApplyStateContext context, IWriteOnlyTransaction transaction) { } } 为什么我说这个 Filter 有点鸡肋呢？因为你看下面的图就会明白了啊！\\n本文小结 果然，我还是不得不承认，这又是一篇彻彻底底的\\u0026quot;水文\\u0026quot;啊,因为写着写着就发现自己变成了标题党。这篇文章总结下来其实只有两句话，一个不喜欢写 XML 报文的博主，如何与 ERP、SAP、ESB 里的 XML 报文斗智斗勇的故事，在这样一个背景下，为了满足对方的\\u0026quot;异步\\u0026quot;场景, 不得不引入一个后台任务系统来处理这些事情，其实，这个事情用消息队列、用 Redis、甚至普通的中间表都能解决，可惜我写这篇文章的时候，是有一点个人化的情绪在里面的，这种情绪化导致的后果就是，可能我越来越难以控制一篇文章的写作走向啦，大概是写东西越来越困难，而又没有时间取吸收新的知识进来，这让我觉得自己的进步越来越少，Hangfire 的有点说起来就是挺好用的，以上！\\n\"",
            "url": "\"/posts/1071063696/\"",
            "date": "\"2019-07-04\""
        },
        
        {
            "title": "\"你了解爱的艺术吗？\"",
            "content": "\"或许我不是一个懂得如何去爱人的人，我时常陷入一种自我否定的焦虑当中，当我发觉自己喜欢上一个人的时候，从某种意义上它会让我身上的缺点被无情地放大，我并不畏惧在喜欢的人面前暴露这些缺点，因为这就是真实的我，因此我从来不喜欢去塑造别人，让别人成为我心目中期待的样子，可是我会忍不住去塑造我自己，尤其是在和别人相处的过程中，发现我身上的缺点或者问题的时候，我习惯了对自我严格，虽然我知道这个过程注定痛苦，可是你能告诉我，爱到底是什么吗？如果爱不足以让我们改变，我们喜欢的究竟是一个怎样的自己、怎样的别人？\\n弗洛姆这本《爱的艺术》是我自己为自己挑选的一本书，在我买了 Kindle 以后，我将我的时间安排在看书和学习上，因为我的确很喜欢读书，而我这种理性的性格有时候难免让人讨厌，所以读书特别是选择去读人文类书籍，从某种意义上来说是我在刻意地稀释这种理性思维造成的影响，《黑客与画家》里告诉我们一件事情，聪明人不被周围人喜欢是因为他们比周围人聪明，当谈恋爱越发地被人们改造成一种套路，我们对爱的定义或许会越来越模糊，可是爱作为一种大自然间普遍存在的情感，我坚信它是一种相当原始而简单的事情。\\n弗洛姆认为，爱情是对人类生存问题的回答，人们在这个世界上逐渐意识到生不由己、意识到死的必然、意识到孤独和与世隔绝、意识到面对社会和自然的威力时的无能为力，所以，所有生活在不同文化和时代里的人，都面临着一个同一个问题，即：如何克服这种孤独感。古人说“古来圣贤皆寂寞，唯有饮者留其名”，其实何止是古来圣贤，我们生活在这个地球上的所有人，从出生到死亡都不可避免地被一种孤独感包围者，曾经和别人 讨论过这个问题，我对人情颇为淡漠，因为我觉得除了能够真正将彼此联系起来的两个人，在这个世界上你永远无法找到真正能让你灵魂皈依的地方，这种感觉并非是由血缘或者金钱这样的关系来维系，一个人的孤独与一群人的孤独，在整个宇宙间看起来，其实没有什么不同。\\n爱的确是一门艺术，可对我们每个人而言，它像是某种缥缈甚至是难以揣测的情绪，你不能用一种非常理性的眼光来审视和定义它的存在，弗洛姆说：“不是拥有财物的人是富裕的，而是给予他人东西的人才是富裕者”，可现实是并非你不顾一切地对一个人好，就能赢得一份让你感动的爱情，所以在经历过挫折以后，我不再考虑一味地索取或者付出，我喜欢将这个过程叫做分享，人们在分享的过程中认识彼此、丰富彼此、提高彼此的生命感，这是我认为在爱情中我们需要去挖掘的一种潜质，如果一个人没有生命力，就不会有创造爱情的能力，所以当我们试图爱一个人之前，我们首先要学会爱我们自己，而弗洛伊德将这种人的自我欣赏叫做“自恋”，除了爱情自身积极性的因素以外，爱情具有所有爱的形式所共有的因素，如：关心、责任心、尊重和理解。\\n爱情不是自私地占有对方或者是放弃除对方以外人的更为广泛意义上的博爱，“爱情是自由之子，永远不会是控制的产物”。或许我们穷极一生来认识自己、认识别人，可我们最终还是不认识自己、不认识别人，可我们无法阻止这种深入了解人的灵魂的秘密、了解人的核心，即“自我”的愿望将继续存在。毫无疑问，德尔斐的人箴言“认识你自己”表达了我们认识自己和他人的愿望。白昼和黑夜表面看起来是敌人，但它们却都是为了一个目标，因为相爱就是为了完成共同的事情。而从广义的爱的定义来看，中国古代先哲孟子的“老吾老以及人之老，幼吾幼以及人之幼”就很好的表达了这种观点，弗洛姆说：“一切爱的形式都以博爱为基础，我指的博爱就是对所有的人都有一种责任感，关心、尊重和了解他人，即愿意提高其他人的生活情趣”。以前以为爱是自私地占有一个人，是对除对方以外的人表现得漠不关心，可后来逐渐发现，我们对自己的爱远远超过别人，这或许不能叫做爱吧！\\n我们来到这个世界上，更本质的意义在于我们希望认识些有趣的人，做些有趣的事情而已，这意味着我们常常试图在这个世界上留下自己的印记，我们习惯了在朋友圈里晒美食、晒旅游、晒自拍等等约定俗成的处事方法，亦如我们生来就渴望被人理解、被人喜欢一样，而这一切更本质的原因，我们现在称为“刷存在感”，恰恰迎合了这个观点，我们想要在这个世界上留下我们的印记，即使这些方式方法看起来并不是我们最初喜欢的样子，弗洛姆将在这个观点理解为“超越自己”的追求，这一追求属于人的最基本要求，即“人对自己的纯生物作用不满，他不能忍受自己仅仅是被扔进这一世界的小卒。他一定要感到自己是创造者，是能超越处于被创造者消极地位的生命。满足这一要求有许多可能性，最自然和最基本的途径就是母亲对自己创造物的关怀和爱”。所以，我们渴望被人喜欢、被人理解都是因为我们希望生来独特、生来不同，而这一切都源于父母对爱的一种创造力。\\n我们常常表现出，一种试图要要证明比别人过得更好的心态，仿佛在朋友圈或者微博这种社交平台上，我们能找到更多的自豪感，可我同样知道，这个世界上最大的社交网站 Facebook，背后却是由一个有社交障碍的人创造出来的，我们都渴望让别人了解自己、认识自己，这不同于社交场合里那种客套的场面话，对此，弗洛姆认为，人与人之间可以通过讲述这种方式来打破人与生俱来的这种孤独感，“讲述自己的生活，叙述自己的希望和恐惧，谈出自己幼稚的或者不成熟的梦想，以及找到面对世界的共同利益——所有这一切都是克服人与人之间隔离的途径，甚至表露自己的愤怒和仇恨，毫无顾忌地交心也都被看作是亲密的表现”，我们对爱的终极理解其实应该是，我们通过爱一个人，进而爱全人类，爱一切生命，我们从自我的生命的本质出发去爱对方，并且去体验对方的本质，爱情是意志的行为，是人作的一项把全部生命交付对方的决定。\\n圣经中“爱他人如同爱己”的说法，说明了对自己的完整性和独特性的尊重，爱自己，理解自己同尊重、爱和谅解别人是不可分割的，爱我同爱他人是紧密相连的。中世纪德意志神秘主义哲学家和神学家，爱克哈特有一句关于自爱的格言：“你若爱己，那就会爱所有的人如爱己。你若对一个人的爱少于爱己，如果你不是爱所有的人如同爱己，如果你不是在一个人身上爱所有的人——因为这个人就是上帝和人。一个既爱自己又爱他人如同爱己的人就是这样的人，一个值得这样评价的人”。我们来到世界上学会与人相处、学会如何去爱一个人，其实是在寻找一种探索生活所需要的信仰，因为生存或许会非常容易，可是学会生活或许会非常困难，我们努力提高生活质量，源于我们对自己和伴侣的一种爱，希望让彼此变得更好。\\n或许对弗洛姆本人而言，这本《爱的艺术》更像是 他对自我的一种内省，因为他的爱情基本上在持续地遭遇着失败，他曾经和四个不同的女人结过婚，所以他在这本书里提出的大量观点都来源自他自己的感情经历，他早期研究过弗洛伊德的相关理论，而事实上，因为对爱的无能为力让他真正找到了爱的能力，我们在年轻的时候总会遇到一个非常喜欢，可我们却无法给她想要的生活的女孩子，或许我们都需要用一生去领悟爱的真正含义吧，就像弗洛姆这本书是建立在将理论和实践结合起来的基础上的，我不认为我此刻已经读懂了这本书，可是它对我的确非常重要，我总要学着去爱别人，让自己变得更好！\\n\"",
            "url": "\"/posts/2275646954/\"",
            "date": "\"2016-09-24\""
        },
        
        {
            "title": "\"使用 Mono 让.NET 程序跨平台运行\"",
            "content": "\"众所周知，Unity3D 引擎凭借着强大的跨平台能力而备受开发者的青睐，在跨平台应用开发渐渐成为主流的今天，具备跨平台开发能力对程序员来说就显得特别重要。传统的针对不同平台进行开发的方式常常让开发者顾此失彼，难以保证应用程序在不同的平台都有着相同的、出色的体验，这种情况下寻找到一种跨平台开发的方式将会为解决这个问题找到一种思路。从目前的开发环境来看，Web 应该是最有可能成为跨平台开发的神兵利器，可是长期以来 Web 开发中前端和后端都有各自不同的工作流，虽然现在出现了前端和后端逐渐融合的趋势，可在博主看来想让 Web 开发变得像传统开发这样简单还需要一定的过渡期。\\n从 Mono 到 Xamarin 对 Unity3D 来说，Mono 是实现它跨平台的核心技术。Mono 是一个旨在使得.NET 在 Linux 上运行的开源项目。它通过内置的 C#语言编译器、CLR 运行时和各种类库，可以使.NET 应用程序运行在 Windows、Linux、FreeBSD 等不同的平台上。而在商业领域，Xamarin 则实现了用 C#编写 Android 和 iOS 应用的伟大创举。Windows10 发布的时候，微软提出了通用应用 UWP 的设想，在这种设想下开发者可以直接在最新的 Visual Studio 中使用 C#编写跨平台应用。最近微软收购了 Xamarin，这一举措能够保证 Xamarin 这样的商业项目可以和微软的产品融合地更好。虽然在传统 Web 开发中 Java 和 PHP 目前占据主要优势，可是虽然云计算技术的流行，服务器成本的降低或许会让 C#这样优秀的语言更加成熟。我一直坚信技术没有好坏的区别，一切技术问题的核心是人，所以接下来，我们打算追随着跨平台开发的先驱——Java，最早提出的“一次编写、到处运行”的伟大思想来探索 C#程序跨平台的可能性。\\nMono 跨平台的原理 在提到 Mono 跨平台的时候，我们首先需要引入公共语言基础(Common Language Infrastructure，CLI)这个概念，CLI 是一套 ECMA 定义的标准，它定义了一个和语言无关的跨体系结构的运行环境，这使得开发者可以用规范定义内各种高级语言来开发软件，并且无需修正即可让软件运行在不同的计算机体系结构上。因此我们可以说跨平台的原理是因为我们定义了这样一个和语言无关的跨体系结构的运行环境规范，只要符合这个规范的应用程序都可以运行在不同的计算机体系结构上，即实现了跨平台。针对这个标准，微软实现了公共语言运行时（Common Language Runtime，CLR)，因此 CLR 是 CLI 的一个实现。我们熟悉的.NET 框架就是一个在 CLR 基础上采用系统虚拟机的编程平台，它为我们提供了支持多种编程语言如 C#、VB.NET、C++、Python 等。我们编写的 C#程序首先会被 C#编译器编译为公共中间语言即 CIL 或者是 MSIL(微软中间语言)，然后再由 CLR 转换为操作系统的原生代码（Native Code）。\\n好了，现在我们来回答最开始的问题：Mono 为什么能够跨平台。我们回顾.NET 程序运行机制可以发现实现.NET 跨平台其实需要这三个关键：编译器、CLR 和基础类库。在.NET 下我们编写一个最简单的“Hello World”都需要 mscorlib.dll 这个动态链接库，因为.NET 框架已经为我们提供了这些，因为在我们的计算机上安装着.NET 框架，这是我们编写的应用程序能够在 Windows 下运行的原因。再回头来看 Mono，首先 Mono 和 CLR 一样，都是 CLI 这一标准的实现，所以我们可以理解为 Mono 实现了和微软提供给我们的类似的东西，因为微软的.NET 框架属于商业化闭源产品，所以 Mono 除了在实现 CLR 和编译器的同时实现了大量的基础库，而且在某种程度上 Mono 实现的版本与相同时期.NET 的版本有一定的差距，这点使用 Unity3D 开发游戏的朋友应该深有感触吧！这就决定了我们在将应用程序移植到目标平台时能否实现在目标平台上和当前平台上是否能够具有相同的体验。因为公共中间语言即 CIL 能够运行在所有实现了 CLI 标准的环境中，而 CLI 标准则是和具体的平台或者说 CPU 无关的，因此只要 Mono 运行时能够保证 CIL 的运行，就可以实现应用程序的跨平台。我们可以通过下面这张图来总结下这部分内容：\\n开发第一个跨平台程序 下面我们来尝试开发第一个跨平台程序，我们使用 Visual Studio 或者 MonoDevelop 编写一个简单的控制台应用程序，为了减少这个程序对平台特性的依赖，我们这里选择 System 这个命名空间来实现最为基础的 Hello World，这意味着我们的应用程序没有使用任何除 mscorlib.dll 以外的库：\\nusing System; namespace MonoApplication { class MainClass { public static void Main(string[] args) { Console.WriteLine(\\u0026#34;Hello World!\\u0026#34;); } } } 因为我们的计算机安装了.NET 框架，所以我们编写的这个程序会被 C#编译器编译为公共中间语言 CIL,然后再由 CLR 转换为 Native Code。通常情况下公共中间语言(CIL)会被存储到.il 文件中，可是在这里我们在编译的时候好像并没有看到这个文件的生成啊，这是因为这里生成的可执行文件(.exe)本质上是公共中间语言(CIL)形态的可执行文件。这一点我们可以通过 ildasm 这个工具来验证，该工具可以帮助我们查看 IL 代码，通常它位于 C:\\\\Program Files\\\\Microsoft SDKs\\\\Windows\\\\v7.0A\\\\bin 这个位置。下面是通过这个工具获得的 IL 代码：\\n.method public hidebysig static void Main(string[] args) cil managed { .entrypoint // 代码大小 13 (0xd) .maxstack 8 IL_0000: nop IL_0001: ldstr \\u0026#34;Hello World!\\u0026#34; IL_0006: call void [mscorlib]System.Console::WriteLine(string) IL_000b: nop IL_000c: ret } // end of method MainClass::Main 可以看到这段代码和我们编写的程序中的 Main 方法完全对应，关于这段代码的含义，大家可以通过搜索引擎来了解 IL 代码的语法。因为我们这里想要说明的是，这里生成的可执行文件(.exe)从本质上来讲并非是一个可执行文件。因为它能否执行完全是取决于 CPU 的，这和我们直接用 C++编写的应用程序不同，我们知道不同的编译器如 Windows 下的 VC++和 Linux 下的 GCC 都是和硬件紧密相连的，所以我们编译的程序能够在各自的平台直接运行，即 CPU 是认识这些程序的。可是在.NET 这里就不一样了，因为我们通过 C#编译器即 csc.exe 编译出来的文件，其实是一个看起来像可执行文件，实际上却是一个和平台无关、和 CPU 无关的 IL 文件。\\n那么我们就会感到迷茫了啊，平时我们编译完 C#程序双击就可以打开啊，哈哈，现在隆重请出.NET 程序的家长公共语言运行时(CLR)。公共语言运行时实际上是程序运行的监管者，程序运行的情况完全由运行时来决定。我们双击这个文件的时候，公共语言运行时会将其加载到内存中，然后由即时编译器(JIT)来识别 IL 文件，然后由 CPU 去完成相应的操作。\\n所以我们可以这样理解.NET 程序跨平台，因为 IL 文件是一个和平台无关、和 CPU 无关的、跨平台的文件结构，所以我们只需要在不同的平台上实现这样一个公共语言运行时(CLR)就可以实现在不同的平台上运行同一个程序。但这个过程中，需要有一个 C#编译器负责将 C#代码转换为 IL 代码，然后需要有一个公共语言运行时(CLR)来解析 IL 代码。与此同时，我们在.NET 框架下使用了大量的基础类库，这些类库在 Windows 以外的平台是没有的，所以除了 C#编译器和公共语言运行时以外，我们还需要基础类库。现在大家是不是对 Mono 有了更清楚的认识了呢？没错，Mono 所做的事情其实就是我们在讨论的这些事情。这里博主想说说即时编译(JIT)和静态编译(AOT)，这两种编译方式我们可以按照\\u0026quot;解释型\\u0026quot;和\\u0026quot;编译型\\u0026quot;来理解,为什么 Unity3D 在 iOS 平台上做热更新的时候会出现问题呢？这是因为 iOS 平台考虑到安全性禁止使用 JIT 即时编译，所以像 C#这种需要编译的语言在这里就无计可施了。\\n好了，既然我们有 Mono 这样的工具能够帮助我们实现跨平台开发。那么我们现在就来考虑将这个程序移植到 Linux 平台，这里以 Linux Deepin 为例，我们按照 C#程序编译的过程来完成这个移植过程：\\n1、将 C#程序编译为 IL 文件：在.NET 下我们使用 csc.exe 这个程序来完成编译，在 Mono 下我们使用 mcs.exe 这个程序来完成编译，这个程序在安装完 Mono 以后在其安装目录内可以找到。我们在命令行下输入命令： mcs D:\\\\项目管理\\\\CSharp\\\\MonoApplication\\\\MonoApplication\\\\Main.cs 2、这样将生成 Main.exe 这样一个 IL 文件，现在我们需要一个运行时来解析它，在.NET 下我们使用 CLR 来完成这个步骤，在 Mono 下我们使用 mono.exe 这个文件来完成这个步骤。我们在命令行下输入下列命令： mono D:\\\\项目管理\\\\CSharp\\\\MonoApplication\\\\MonoApplication\\\\Main.exe 我们可以看到命令行下输出了我们期望的 Hello World，这意味着我们编写的程序现在运行在 Mono 中了，实际上在 Windows 下由 Mono 提供的 C#编译器 mcs.exe 编译的 IL 文件双击是可以直接运行的，因为我们的计算机上安装了 CLR，它作为.NET 的一部分内置在我们的计算机中。由此我们会发现一个问题，我们这里的跨平台实际上是编译器、运行时和基础类库这三部分的跨平台，这意味着我们在 Linux 下运行.NET 程序是需要 Mono 提供支持的。因为在这里我无法在 Linux 离线安装 Mono，所以 Linux 下运行.NET 程序的验证需要等博主以后有时间再来更新啦！可是我们可以想象到，通过 C#编译器编译得到的可执行文件在 Linux 下是无法正常运行的，因为通常情况下 Windows 程序在 Linux 下运行是需要虚拟机环境或者 Wine 这样的软件来支持的，显然让这样一个 Windows 程序运行在 Linux 环境下是因为我们在 Linux 下安装了 Mono。\\n谈谈 Mono 跨平台以后 好了，到现在为止我们基本理清了 Mono 跨平台的原理。我们知道微软的技术体系在发展过程中因为某些历史遗留问题，.NET 程序在不同的 Windows 版本中的兼容性有时候会出现问题，虽然微软宣布 Windows XP 停止维护，我们编写 Windows 应用程序的时候可以忽略对 Windows XP 版本的支持，可是因为国内用户不喜欢在线更新补丁的这种普遍现状，所以假如让用户在安装程序的时候先去安装.NET 框架一定会降低用户体验，其次.NET 框架会增加应用程序安装包的大小，所以我们需要一种能够让我们开发的.NET 应用程序在脱离微软的这套技术体系时，同时能够安全、稳定的运行，所以我们这里考虑借助 Mono 让.NET 程序脱离.NET 框架运行。\\n首先，我们来说说.NET 程序为什么能够脱离.NET 框架运行，我们注意到 Mono 提供了一个 Mono 运行时，所以我们可以借助这样一个运行时来运行编译器生成的 IL 代码。我们继续以 Hello World 为例，我们在使用 Mono 编译出 IL 代码以后需要使用 Mono 运行时来解析 IL 代码，所以假如我们可以编写一个程序来调用 Mono 运行时就可以解决这个问题。在这个问题中，其实精简应用程序安装包的大小从本质上来讲就是解决基础类库的依赖问题，因为 Mono 实现了.NET 框架中大部分的基础类库，所以移植.NET 应用程序的关键是基础类库的移植，比如 WinForm 在 Linux 下的解决方案是 GTK，这些细节在考虑跨平台的时候都是非常重要的问题。\\n小结 本文从 Mono 跨平台的原理说起，探讨了.NET 应用程序跨平台的可能性和具体实现。跨平台是一个涉及到非常多内容的话题，我个人理解的跨平台是要编写跨平台的代码，这意味着我们在编写程序的时候需要考虑减少对平台特性的移植，比如说 Linq 是一个非常棒的特性，可是这个特性离开了 Windows、离开了.NET 就没有办法得到保证，所以如果要让使用了 Linq 的应用程序跨平台就会是一件非常麻烦的事情！在不同的平台间保持相同的体验很难，就像我们编写的 Web 程序在不同的浏览器间都有着不一样的表现，所以跨平台这个问题我们就抱着学习的态度来研究吧！\\n\"",
            "url": "\"/posts/1836680899/\"",
            "date": "\"2016-03-06\""
        },
        
        {
            "title": "\"《仙剑奇侠传六》游戏感言\"",
            "content": "\" 目前游戏主线剧情进行到 50%左右，在游戏尚未通关前，我对于这一部游戏的感觉始终是一种说不清道不明的情感，作为仙剑系列中唯一一部，从项目立项到宣传曝光再到游戏上市整个过程中持续关注的游戏，它可以说是承载了无数玩家的期待和祝福。和大部分玩家一样，在游戏曝光的第一时刻我们曾经热火朝天地讨论过各种各样可能的设定、曾经为这部游戏的系统玩家想过各种各样的尝试，然而当我面对这款游戏的时候，我的内心平静得像一潭死水。我今天 23 岁，刚刚从大学毕业的我本应该还没有被这个社会完全改变，可我不知道是我变了还是仙剑变了，这一次打开仙剑的时候，我总有一种恍若隔世的恍惚感。\\n引子 曾经，仙剑一的游戏开始界面是简单到不能再简单的竹简、酒葫芦、剑，这些元素组合起来就仗剑江湖的行侠仗义、白云苍狗的醉梦人生和徐徐道来的温暖故事；曾经，仙剑三的《御剑江湖》伴随着云山雾绕的蜀山像一幅遗留在历史深处的卷轴缓缓地打开让人不由得心头一阵惊艳；曾经，仙三外传开头蜀山掌门大战狼妖，无数道剑气凝成的剑柱从天而降可以让你感受到那种仙家道法的玄妙和奇幻；曾经，仙剑四的《回梦游仙》在耳畔响起的时候卷云台像朵清新脱俗的莲花静静地盛开却在最后一刻明白这朵莲花是一切悲剧的开始；曾经，仙剑五前传的明州码头在夕阳和晚霞的交相辉映中，瑾轩和瑕妹依偎在一起看着落霞与孤鹜齐飞是永远的温馨画面……\\n可是仙剑六让我看到了什么呢？我看到了一片经过高斯模糊的绿油油的草地，没错！它真的是一片绿油油的草地，以至于当我打开这个游戏的时候我不得不在心里问自己：这真的是一个古风的仙侠/武侠游戏吗？在仙剑奇侠传六的宣传阶段，我在我的 QQ 群里、我的博客中不断向大家输送着这样一个概念：仙剑六是仙剑奇侠传系列二十年的突破之作，它一定不会让大家失望的，甚至我不遗余力地和游戏圈子里使用 Unity3D 引擎开发游戏的朋友们说，看，仙剑六是使用 Unity3D 引擎开发的，它的画面是历代游戏中最好的，这一次它终于要尝试即时战斗了。然而当我打开这个游戏的时候，我知道自己会被打脸，尤其是当我面对接受了我的这些观点的朋友的时候。\\n对于此次仙剑六游戏优化的问题，我不想做详细的说明，我更不想为北软洗白，当我们觉得仙剑奇侠传六之泰坦陨落变成一个笑话的时候，我觉得我们可以说说 Unity3D 这个游戏引擎了。我承认，Unity3D 是个手机游戏引擎；我承认，Unity3D 在画面表现上无法和 UE、CE 这些顶级的游戏引擎相提并论；我承认，现在国内各种各样的 Unity3D 教程满天飞；我承认，Unity3D 入门快、成本低、跨平台性能强……可是这些都不是你们不用心做仙剑六的理由好吗？在我看来，技术从来都没有优劣之分，真正让技术体现出差异的是使用工具的人。Unity3D 本质上并非是一个差劲的游戏引擎，所以以引擎来论仙剑六的成败是不恰当而且不应该的，因为使用 Unity3D 开发的游戏目前已经相当的多了，比如《蒸汽之城》、《太空冒险》、《新仙剑 OL》等等以及无数的手机游戏。可是能将这个引擎用到如此地步的恐怕只有仙剑六吧！目前 Unity3D 的授权方式是收入超过 3 万美元即 18 万人民币左右需要按照一定的比例向 Unity3D 官方支付费用，我不知道这次的优化问题是否会对仙剑六的销量产生影响，可是我觉得恐怕官方都会认为这款游戏存在影响 Unity3D 引擎声誉的问题吧！\\n画面 首先我们来说说游戏画面，我不知道有多少玩家可以在这款游戏中保证特效全开，总之在我的电脑上看起来整个画面有一种糊糊的感觉，远景看起来比较唯美壮丽，然而当我将镜头拉近的时候我觉得我还是不要计较仙剑奇侠传这个游戏的画面了吧！可是我真的不理解，作为仙剑奇侠传系列的好兄弟轩辕剑系列在使用 Unity3D 制作了两款游戏这样的背景下，北软为什么就不肯向 DOMO 小组学习哪怕借鉴相关的经验呢？虽然《轩辕剑六》恶名在外、《穹之扉》销量不佳，可是最起码人家的游戏的画面做得相对仙剑六要好很多好不好，况且人家在处理人物和场景时刻意加强了人物面部的特征，通过渲染景深和整体的光照使得画面透露出一种唯美的风格。可是仙剑六呢？仙剑六中做得最好看的永远都是人物的脸，我不知道北软是不是在有意告诉大家：这是一个看脸、靠脸的时代，所以当我们面对这个游戏的时候我们就发现整个游戏除了脸比较漂亮以外基本没有什么优点，可是事实上不同的人物在不同的场合、年龄他的面部应该都是不一样的啊，北软你把所有人的脸都做的这么漂亮，是想告诉玩家都不用去努力工作、只要拼脸就可以了吗？我不知道使用国外的 3A 级别的游戏引擎如 UE、CE 等来表现这种中国古典美的场景是否合适，因为这种类型的引擎更适合写实的渲染，而无疑中国的古风游戏需要的是一种意蕴上的美感的渲染。然而《古剑奇谭》和《轩辕剑》在表现这种场景时处理的相对来说是比较好的，这次的所有场景中我比较喜欢的是与青山，因为这个场景的色彩运用可以让玩家很明显的区分开场景中的不同的区域，反观忘尘寰、归墟、天晴之海、饮马河等场景因为使用的色彩较为接近，因为在玩家探索迷宫的时候常常搞晕，再辅以本次游戏中那个神奇的相机视角，探索迷宫的乐趣真是大大的增强啊！我不理解为什么北软连全局光照这种只需要简单设置下参数的东西都不愿意用，却要花大力气在角色的头顶上放置点光源，你告诉我，放置点光源就是为了让角色的头顶亮一下、脸白一点吗？更不要说启魂邪教总坛里那些支持实时反射的水晶石了？难道你宁可要这种华而不实的效果，都要让玩家的计算机耗费资源去支持它吗？景安正武盟门前的那条河的果冻绿材质就不能让美术想办法替换下吗？难道怕玩家不知道你是使用的 Unity3D 里的标准材质？\\n下面是游戏中主角及配角的面部截图，颜值爆表啊！\\n下面是《古剑奇谭二》、《穹之扉》、《仙剑六》三部游戏在特效全开的情况下的画面表现，相信高下立判了吧！\\n建模 好了，下面说说建模的问题，我使用 disunity 对仙剑六的部分.unity3d 文件进行了解包，然后发现每个模型文件的包大概在 10M 左右，像太空步、循环动画、穿模这种问题我就不说了，反正每次说了你们又不打算改。我就来说说这个游戏里的模型吧？对三个模型进行了解包，然后发现这三个模型的单位都是不一样的，就是说在 scale 为 1、1、1 的时候三个模型的大小是不一样的；其次模型的角度需要手动改为-90,180,0，我觉得建模的时候难道不应该制定相关的规范吗？我觉得从 Max、Maya 里导出到 FBX 到 Unity3D 的时候难道不应该规范单位、角度和中心点位置吗？我从来不认为游戏引擎就是美术把模型做好了给程序用就行了，我觉得美术在建模的时候更应该去关注模型在这个引擎下的渲染效果，如怎么调整材质、怎么打灯光等等的问题，这些问题不应该推给程序而且不能推给程序。从模型贴图来看，美术想到了诸如法线贴图等等的次世代特性，可是到了实际使用的时候，我看到的结果的是整个游戏里基本清一色的使用了 Diffuse 着色器，那请问这样做这些贴图有什么意义？既然你根本用不到为什么还要放到游戏里？而且我在模型文件中经常看到诸如 Object01 或者 A_toufa、B_yifu 这样的命名，我是一个程序员，对命名比较敏感，我觉得出现汉语拼音式的命名，说明建模的人是特别不专业的。然后我想说的是这次整体美术风格的问题，难道大家不觉得天晴之海的建筑风格偏欧式了吗？这是一个中国的古风游戏啊！难道大家不觉得盈辉堡的道路和房子都是一样的颜色吗？我在地图里转了半天才找到路啊！此次的配角如赢旭危和朔漩的建模普遍要比主角团好看多了，难道你们要开始学《古剑奇谭二》在游戏中潜伏隐藏主角团吗？我不知道一个 2015 年的游戏出现 NPC 配音时嘴巴不动是出于什么考虑？NPC 不重要吗？NPC 戏份没有主角团多可以忍、长得没有主角团帅可以忍，可是你剥夺人家说话的权利是什么鬼？还有骆驼移动的时候没有移动动画直接悬空移动又是想干什么？一个骆驼值得你使用刚体这样的移动方式去移动吗？关于游戏读条慢的情况，我自己测试了下、同时找了相关的资料去查阅，Unity3D 场景的异步加载的确有坑存在，可是我相信只要运用合适的方法是可以规避这个问题的，因为目前仅仅解了部分 AssetBundle 包的内容，所以对程序内部的一些东西还有待确定，等确定后会继续更新到这里。\\n剧情 剧情、配音、配乐这里放到一起说，因为这是仙剑六引以为豪的地方，此次的剧情主线有两条，即双越身世之谜和洛家双生子早逝之谜，将这两条线交织在一起的是横道众和柷敔间的矛盾冲突，这样的设定明显是继承了仙五前的多线程叙事方式，这样的叙事方式应该是值得肯定的。但是我不能理解整个游戏到底是以谁为叙事中心的，正如仙剑五是以主角姜云凡为叙事中心的，他所看到的一切推进着整个剧情的深入，再入仙剑五前传是以主角夏侯瑾轩为叙事中心的，围绕着为姜承洗刷冤屈、为瑕妹治病两条主线将所有相关的人或事联系了起来。可是仙剑六我真没看出来是以谁为中心的，整个主角团是仙剑史上最冷漠、最分裂的团队，将大家联系到一起的唯一理由就是存在感爆表的神农九泉，然而这并没有什么卵用，大家都是站在自己的立场上做着自己关心的事情。\\n比如越今朝是霸道总裁“只有我一个人可以叫你祈”。一路上不是摸头就是捏脸，可惜手压根没有放到脸上去；再比如越祈是天真傻“我听今朝的”。一路上吃面吃得我都饿了，可是那碗鸡蛋面就是一张贴图啊，吃半天空气最后居然吃完了，我要向仙剑六的四位程序员致敬；再比如闲卿是典型的双标狗，一面要讨好老婆洛昭言和世侄小绣儿，一面还要做出一副闲适淡泊的样子，我都忍不住要为你的演技点赞；再比如耳光绣明绣，我觉得要么是美术和策划有仇，故意将这样一个凶狠的角色画成甜美可人的女神范儿，要么就是编剧经常看琼瑶剧比较热衷于打人耳光，一个武侠游戏有什么不满直接亮兵器不就好了，要是当年月如被逍遥在扬州城外欺负了直接打李逍遥一个耳光，我觉得这个角色恐怕要失去不少忠实粉丝吧;再比如说技术宅居士方这货总是一副“你们都是对的，怪我咯”的态度，我至今都想不明白他有什么不对的地方，既然大家都不拿你当朋友，你凭什么要为这样一群人牺牲豆包啊。我一直喜欢仙剑营造的那种朋友间比较温暖的情感，比如仙剑四里小紫英一句“承君此诺必守一生”就会让人觉得温暖，即使以后大家分开了彼此的心中还可以相互牵挂。可是仙剑六呢，那晚大家做一起赏月喝酒本来应该是彼此相互了解和认识的机会，结果大家都忙着去约会了，留下居十方一个人在哪里喝闷酒，甚至他喝醉了酒吐露心事主角团中竟然无一人听见，我严重怀疑编剧每次和同学聚会的时候都是那个抢着麦克风嘶吼却从来不会有人去安慰他的那个人，编剧啊，己所不欲勿施于人啊。我一直认为一个 RPG 游戏的核心在于代入感，就是说你要让玩家觉得他就是游戏中的主角。比如我们玩仙剑一的时候就感觉自己是李逍遥，仙五前谢叔单挑姜世离的时候我们就感觉自己是谢叔，这就是代入感。\\n可是仙剑六呢，居然巧妙的避开了这一点，搞得从头到尾都像在看电影，不，应该是叫做在看幻灯片。我不知道仙六是不是借鉴了《古剑奇谭二》的叙事方式，整个叙述视角更像是以上帝俯视人间的视角在讲整个故事，如果说《古剑奇谭二》成就了流月城，那么仙剑六便成就了衡道众，而且编剧觉得为了和《古剑奇谭二》拉开差距，刻意让站在对立面的衡道众认识到自己的错误并对主角一行人提供了补偿。我承认，这让仙剑六在立意上有了深度，可是我接下来要说的就是你们的不对了。我们玩仙剑一的时候比武招亲、蜀山剑法、林家绝学、苗疆蛊术、五灵仙术我们从来不会觉得存在违和感，因为这些东西都是东方文化中已有或者说可以找到起源追朔的东西，可是仙剑六的编剧你告诉我整个仙剑六除了鲲鹏能够在庄子的《逍遥游》中找到记载以外，其他的这些是中国传统文化存在的吗？是，时空穿越早就有了，可是回魂仙梦和血濡回魂都无法改变已经发生的事情；是，在天上飞早就有了，可是蜀山仙剑派御剑飞行早在武侠小说、志怪小说中有记载，所以蜀山的御剑术不会存在丝毫的违和感，可是你搞个二十一世纪都未必有的飞行器是什么鬼，古时候尝试上天的人最多是在一个椅子上捆满火药，希望通过反冲力飞到天上去，结果为科学事业献身了，编剧你告诉我这是什么鬼。我真傻，我单单知道黑科技会在仙剑剧里出现，却不知道有一天会在仙剑游戏里出现，你告诉我御界枢的人都是外星人吗？我们使用智能手机、平板电脑不过四五年的样子，编剧你告诉我衡道众里的人是怎么做到的，他们是从未来穿越过去的嘛？好了，下面请允许我替历代仙剑中因为剧情需要而牺牲的各位男主角、女主角、男配角、女配角、小怪以及 Boss 说句公道话，为什么六代的人可以通过交换实现“不死”的愿望，而六代以前的就只能领便当？我知道编剧一定会说，因为这次我们采用了全新的以神农为中心的世界观，可是编剧好像忘了神农和女娲差不多是同时在宇宙中产生的吧？我觉得五代的 Boss 魔翳比较冤枉，冒着做坏人的危险、拼着命为魔界找来了水源，结果你说九泉之一的热海同样可以产生水源，我原本只要伤害洛埋名一人就可以取得水源，结果就因为你这奇怪的设定，五代造就了仙剑史上最大的牺牲，编剧啊编剧原来你是真正的幕后黑手，神马黑包子各种连携技全都弱爆了好吗？你把仙剑六的故事设定到仙五前的五六十年里难道不担心这个世界的变化跟不上你的节奏吗？编剧你一句话就让蜀山派这样的神权天授、依靠盘古之心存在于世间的正派组织荡然无存啊，你告诉我御剑术都在江湖上失传了，这是摆明了以后不会再出现蜀山或者御剑术的节奏吗？我乐意看到仙剑六在世界观上的变化，可是这个新的世界观应该是原来以女娲为中心的世界观的一种补充而非推翻啊，你提出了神农九泉的概念，我觉得这个设定可以让仙剑的题材变得新颖些，然并卵这一次就把九泉的故事差不多都讲完了，是想等下一部游戏立项的时候再次推翻这次的设定，编剧啊，你到底是来挖坑的还是扩展仙剑的游戏世界观的啊！\\n游戏性 下面我们来重点说说游戏性。你问我为什么要说游戏性啊？一个游戏、一个商业游戏不提游戏性你觉得提什么呢？首先我想强调一个观点，认为仙剑六只要剧情好就行了的朋友请向姚仙建议将仙剑做成一个动漫或者电影，这样大家连自动战斗都不用点了对吧！仙剑六的突破挺多的，可惜注重了量而不注重质，这样平均下来仙剑六的突破其实很少很少。首先，我们来说说开放地图的问题，因为地图开放了玩家可以自由探索的地方就多了，可是你要真的想做好开放地图，就应该认真的去设计空气墙而不是等玩家掉坑里出来的时候打开游戏菜单重新回到原点。因为你们在设置空气墙的时候不用心，在过饮马河和去落日部的路上，比如祈妹的隔空移物和今朝的凌空飞剑，我不会告诉你我是直接从两边的石头上跳过去的。抓猫是挺好玩的，可是你告诉我玩家站在树顶纹丝不动、走绳子如履平地是什么鬼，在没有对 Unity3D 内部集成的 Physic 物理引擎进行完全充分的了解的情况下，贸然使用这样的技术你确定你能驾驭得好吗？浮金堂我跳了一个下午没有跳过去，然后跳出各种 Bug，我终于明白这次为什么有人能玩到 70 个小时以上啦，恭喜北软你们终于知道了怎样延长一个游戏的时间。这次的开机关让居十方都觉得郁闷，因为每次需要开机关的时候都会提示“开机关这种事情还是让十方去做吧!”，当我终于庆幸有用得着十方的时候，这下轮到我郁闷了，难道小游戏就不能给点提示吗？我总得知道自己要做什么吧！划船我再转了不知多久以后才明白过来怎么控制船的移动方向和角度，这种小问题难道每次都要让大家说吗？这次的迷宫设计有了层次感和立体感，比如启魂邪教总坛的迷宫和机关设计得都不错，天晴之海得迷宫设计得比较好，然而我最喜欢的是与青山这个场景！\\n我就放个图，不说话！\\n好了，说完这些小游戏，我们来说说这次仙剑六的战斗系统。我想知道，究竟是什么样的一种考量让你们选择去模仿 FF13 的战斗模式，难道是为了刻意和《古剑奇谭二》有所不同？然并卵，这次的战斗系统糟糕透了。首先，我是希望仙剑的战斗系统慢慢地向着即时制的方向发展的，因为这是现在的大势所趋吧，尤其是《古剑奇谭》、《雨血》和《御天降魔传》这类游戏正在引领着大家的兴趣往即时方向转变，在这样的背景下仙剑积极地向即时制转变从某种程度上来讲是一种不得不采取的防御性措施。可是我有教过你用一个伪即时制的战斗系统来欺骗大家的感情吗？以前大家对排站好在每个回合里我们可以依次控制多名角色，然后依次释放技能，通过不同角色间策略的调整来将游戏进行下去；现在大家迈着太空步，在每个回合里我们可以控制一名角色，每次可以发动多次行动，其他角色由 AI 控制，然后场景中各种粒子特效乱飞。当我看到粒子特效贴图的矩形边框时，我的内心是奔溃的。你告诉我这样的战斗系统和回合制有什么区别？当初主企划说为了让大家更好的观赏战斗画面特意将 UI 做到了右下角，可是你告诉我在一个即时制的游戏里用眼角的余光扫视右下角然后用滚动条从一堆物品中选择需要的物品该有多蛋疼，等你选好了，队友或者玩家可能已经死了。所以我们的数值策划为明绣配置逆天的治疗数值，这样一来大家就不用吃药了。呵呵，是你们该吃药了吧，你告诉我一个游戏玩到现在我都没记住几个技能的名称，以后问起来大家提到万剑诀、天剑、酒神、真元护体、天罡战气、五灵归宗、乾坤一掷、气疗术、气指剑、万物归烬、仙风云体、千方残光剑等等经典招式的时候，我希望你们不要说我们厚此薄彼就好。我相信有好多妹子已经习惯开着自动战斗直接看剧情的习惯了吧，如果这样仙剑还不如买小说或者拍动漫呢，正好这次所有的过场动画都是 2D 动画的形式，可是你告诉我 2D 动画是一种风格、3D 建模是一种风格、小剧情表情是一种风格，一个游戏里三种风格，你是打算同时照顾动漫和游戏两个不同群体的玩家吗？然并卵，你这样做了不见得人家会领情，人家会说你抄袭、撞梗，你说你又是何苦呢？我给仙剑六战斗系统提点意见吧，希望可以支持玩家自定义快捷键，比如玩家可以挑选自己喜欢的技能和常用的物品，每次使用都会消耗行动点数，行动点数目消耗完了就触发技能动画，这样至少可以让点鼠标变得高端些，就像英雄联盟说白了就是 Q、W、E 三个键各种按，可是你同样可以装 X 地说这里面涉及到走位和意识。对了，灵脉系统界面能不能点击了以后不要放大，你觉得那样真的好看吗？再说三种培养方式我非得一条路走到黑？\\n好了，熬夜到凌晨三点写完这篇文章，我对仙剑绝对是真爱，我知道一定会有许多人来吐槽我写的这篇吐槽，可我想说的是：你要真的爱它就别总是惯着它，真正的爱从来都不是溺爱！在官方放出第三版补丁后，整个游戏的优化得到了较好的提升，从感官上像个游戏了，如果有朋友还在徘徊不定，不妨在这个时候尝试下吧！以上观点，一家之言，不足为据！\\n\"",
            "url": "\"/posts/1118169753/\"",
            "date": "\"2015-07-24\""
        },
        
        {
            "title": "\"从「复活」和「暂停/恢复」谈游戏数据配置管理\"",
            "content": "\"随着游戏制作技术的不断发展，在经历了从 2D 到 3D、从单机到网游、从 PC 游戏到移动游戏的种种演变后，玩家对于游戏质量的要求越来越高，游戏制作的难度相应地增加，整个游戏研发的体系开始变得庞大而复杂，由此就产生了游戏数据配置和管理的相关问题。本文将从游戏中的\\u0026quot;复活\\u0026quot;和\\u0026quot;暂停/恢复\\u0026quot;这两个应用场景的角度来谈谈在游戏开发中如何对游戏中的数据进行管理和配置。\\n为什么要谈游戏数据的配置和管理 不知道大家是不是会和博主有一样的想法，就是当你回头来思考游戏开发的时候，你常常会发现，如果忽略游戏的画面、情节、特效等等这些游戏中的可视化的东西，那么其实游戏从本质上来说就是一个大型的有限状态机(FSM)，而我们通常所做的事情基本就是在维护这个有限状态机里面的各种状态，从游戏加载到游戏开始、从游戏开始到游戏中各种事件的发生再到各种事件影响到整个有限状态机的状态，我们通常所做的事情无外乎是在维护各种状态。这种感觉在 RPG 游戏中可能会更明显些，因为在 RPG 中玩家可能是在场景中行走或者奔跑、可能是在和场景中的某个 NPC 进行对话、可能是在和面前的敌人进行战斗、可能是在和杂货店的老板讨价还价……可以说在整个游戏当中无时无刻不在进行游戏状态的切换，那么在不同的状态间切换的时候，什么最为重要呢？答案是数据。什么是数据呢？玩家的生命值、魔法值、战斗力、防御力，物品的用途、价格、数量，游戏的剧情、对话、音乐等等这些都是数据。当我们在状态间进行切换的时候，其实真正改变的就是这些数据。由此可见，面对复杂而庞大的游戏体系，如何对游戏中的数据进行配置和管理是一件值得我们去思考的问题。\\n从应用场景来看游戏数据的配置与管理 首先我们来从游戏当中的两个常见的应用场景:\\u0026ldquo;复活\\u0026quot;和\\u0026quot;暂停/恢复\\u0026quot;来看看游戏数据配置和管理的重要性。 这里以博主的一款跑酷游戏为例：\\n应用场景——\\u0026ldquo;复活\\u0026rdquo; \\u0026ldquo;复活\\u0026quot;是一个在游戏中特别常见的功能，复活这一设定的好处在于无需重新开始游戏就能再次回到游戏当中，当然这只是我们最为直观的一个感受，更为深刻的原因是，游戏者巧妙地利用了玩家在游戏任务失败那一刻的心理。现在生活中每一个人都喜欢胜利，这种心理到了游戏世界中同样是适用的，因为游戏的目的无非就是让玩家有种成就感以获得快乐。可是当游戏任务失败的时候，玩家会竭尽全力不断尝试去打败 Boss 以获得游戏的胜利，因此在游戏中有这样一个设定，可以引导玩家在游戏中形成消费的习惯，这样游戏就能从玩家身上盈利。好了，我们来看看一个基本的\\u0026quot;复活\\u0026quot;的逻辑吧！\\nprivate void Update() { //如果玩家的生命值大于0则游戏正常进行 if(Player.Hp\\u0026gt;0) { //游戏状态为Normal GameManager.Instance.GameState=GameStateEnum.Normal; //执行正常的游戏逻辑 DoNormalEvent(); }else { //游戏状态为Over GameManager.Instance.GameState=GameStateEnum.Over; //显示GameOver ShowGameOver(); //玩家复活 ReLive() } } 玩家复活需要做两件事情：\\n将游戏的状态从 Over 调整到 Normal 将玩家的状态从死亡调整到正常 调整游戏的状态特别容易，因为 GameManager 是一个典型的单例模式，因此我们可以直接将 GameState 从 Over 变成 Noral。可是对于玩家状态的调整，我们却遇到了困难。问题出在什么地方呢？问题出在我们将玩家的生命值等一系列属性都写在了 PlayerController 这个类中，如果我们将玩家的属性全部都设为 Private，那么我们将无法从外部来调整这些属性。比如我们想让玩家满血复活，可是因为这些属性都是私有的，我们无法从外部访问，所以我们在给玩家恢复生命值的时候，无法获得玩家当前的生命值以及最大生命值。可是如果我们将玩家的属性全部都设为 Public，我们可能不得不去面对在编辑器窗口中为每一个属性去赋值，因为一旦我们试图调整游戏双方力量的平衡时，这将是我们不得不去面对的问题，更为致命的玩家的属性并不是永远不变的，比如在 RPG 游戏中玩家的生命值等属性会随着角色等级的提升而不断增加。因此不管我们将这些属性设为 Public 还是 Private，我们都无法保证每次访问到的这些数据都是最新的数据。换句话说，我们不能想当然地在脚本中将玩家的属性写成一个不变的值，因为这些数据随时都在发生着变化，当然如果像敌人和 Boss 这种数值相对稳定的情况，我们可以直接在脚本中将其写成一个固定值，不过我并不推荐大家这样做。由此可见，游戏中数据配置和管理的一个重要作用是维持各个状态间的正常切换。如图是雨血前传.蜃楼中的复活界面，每次复活需要消耗一个复活玉：\\n那么博主在这款跑酷游戏里面是怎样做这个复活的呢？因为博主当时在设计这个游戏的时候考虑不周，直接将玩家的生命值写成了 100，所以在复活玩家时候，同样是先将游戏的状态调整过来，然后再将相关的 GUI 窗口隐藏，然后将玩家的生命值重新设置为 100，重新生成玩家就好了。正是因为感觉这段时间做游戏缺乏一种良好的游戏架构，所以每次游戏做到最后都是自己把逼到了绝路上，留给了自己一个自己都不想再去维护的烂摊子，这样显然是不好的，所以以后需要在正式动手写代码前做好规划，相信这样就能够保证游戏的质量了吧！任何东西学习到一定阶段都会遭遇瓶颈，尽管打破这种瓶颈的过程是痛苦的，可是如果不去打破它，那么你永远都只能停留在这个位置。\\n应用场景——\\u0026ldquo;暂停/恢复\\u0026rdquo; 和\\u0026quot;复活\\u0026quot;一样，\\u0026ldquo;暂停/恢复\\u0026quot;同样是一个在游戏中常见的功能，该功能是给了玩家暂时离开游戏的一种选择，可以保证玩家在做其它事情的时候不会影响到游戏的进程。比如在仙剑奇侠传、古剑奇谭等游戏中，玩家可以按下 ESC 键调出游戏设置界面，在玩家进入游戏设置界面的这段时间，游戏世界里的时间似乎是静止的，场景中的敌人不会因为玩家在查看系统设置界面就去主动偷袭玩家，因为这种情况下游戏是暂停的。而当玩家退出系统设置界面后，游戏恢复为正常状态。到了移动互联网时代，游戏中出现\\u0026quot;暂停/恢复\\u0026quot;的情况更为普遍，这是由移动互联网时代人们玩游戏更注重休闲和娱乐这样的性质来决定的。记得天天酷跑刚刚在微信上线的那段时间，我身边好多同学都在上课的时候玩，可是因为这游戏一跑起来就根本停不下来，所以经常是一次游戏玩下来一节课就结束了。博主不提倡这样啊，玩游戏归玩游戏，可是什么事情都要有个度啊，不然就会变成玩物丧志。好了，我们分析这个案例的目的无非就是想告诉大家在游戏里增加这样一个\\u0026quot;暂停/恢复\\u0026quot;的功能还是十分必要的。好了，现在我们来分析下在这个应用场景中发生状态转换的时候都会牵扯到那些数据吧！\\n首先，游戏暂停后，场景内所有的物体都会停止运动，此时游戏中每个物体的状态都发生了变化，不过因为在 Unity3D 中控制游戏暂停/的恢复主要是通过调整 Time.timeScale 的值来实现的。当 Time.timeScale 取值为 0 时，游戏暂停；当 Time.timeScale 取值为 1 时，游戏恢复正常。不过需要注意的是 Time.timeScale 会对 Unity3D 中所有的时间产生影响如 FixedUpdate()、协程、Destroy()、动画组件等等，所以如果对暂停后的游戏状态有特殊要求的话，建议还是通过其它的方法来实现吧！这里没有提到 Update() 和 LaterUpdate() 这是因为这两个方法不会受到影响。我们来看这样一段代码：\\n//游戏是否暂停 private bool isPause = false; //暂停/恢复游戏的方法 private void Resume() { if (!isPause) { Time.timeScale = 0; isPause = true; } else { Time.timeScale = 1; isPause = false; } } 通过这段代码我们就能够实现一个基本的游戏\\u0026quot;暂停/恢复\\u0026quot;的功能。在游戏管理类 GameManager 中我们定义了一个玩家的得分。正常情况下，当玩家没有死亡的时候会在 GUI 中更新玩家的得分，而玩家的得分是直接采用在 Update()中累加的方式实现的，因此玩家的得分会在游戏暂停后继续更新，这当然是不符合实际情况的，因此可以在这个增量前乘上一个 Time.deltaTime 就可以解决这个问题了。博主举这个例子无非就是想告诉大家使用这种方法来暂停游戏会存在这样的问题，希望大家以后注意啊！\\n游戏数据配置和管理的思路和方法 既然我们在今天的的文章中主要阐述的就是游戏数据配置和管理，那么下面我们就来说说游戏数据配置和管理的常见的思路和方法。根据游戏中数据变动的相对大小，我们将游戏中的数据分为静态数据和动态数据两类。\\n静态数据 静态数据是指在游戏中基本不变或者不需要变动的数据。比如游戏中 Boss 的等级和生命值一般都是确定的，因此这种类型的数据可以称为静态数据。同样地，游戏中 NPC 对话的内容是一种静态数据，因为 NPC 的对话内容是在设计剧情的时候就设计好的无需再对它进行修改。那么对于静态数据，我们可以考虑下列方法：\\n将静态数据作为常量定义在一个类中，这样做的好处是无需对每一个脚本进行修改。 将静态数据存储在文件当中，这样做的好处是可以对数据进行管理，缺点是需要针对不同的文件编写解析接口，游戏开发中常用的数据存储形式有：Json、Xml、Excel、CSV 等。 将静态数据存储在数据库当中，如 SQLIite 等，可是这样做的缺点同样很明显，从本地读取数据库会消耗大量的资源，而且数据库文件一旦丢失，整个游戏都将无法运行。 动态数据 动态数据是指在游戏中会不断变化的数据，比如玩家的得分、玩家的生命值、玩家的经验值等等。动态数据的处理方式除作为常量写在类中以外，其它的都和静态数据是一样的，在此就不再多说了。\\n总结 可能今天这篇文章显得唠叨些，甚至从技术的角度来看，这篇文章都没有讲到什么有价值的技术要点。可是在博主看来，不管一项技术有多么伟大，如果没有良好的架构或者说结构，那么当这个项目的规模到了一定程度以后，这个项目就会出现问题。因为根据破窗户理论，当你看到窗户破了而不去及时修补的话，那么时间一长你破掉的就是整个房子了。回顾博主这么长时间的游戏开发，其实做过的好多游戏到最后之所以没有做完，都是因为到最后项目基本失控、变成了一个连自己都不愿意去维护的项目，这样的情况是可怕的。平时是你一个人做项目，可能你觉得这些都没有什么，可是当你和别人一起去完成这样一个项目的时候，你的这些问题都会成为整个团队的问题。博主一直想知道自己做游戏和团队在一起做游戏会有什么不同，因为博主感觉自己在这一块确实不是掌握得很好。虽然说架构这种事情你做多了才会有经验，可是你现在发现了问题，为什么不在现在改掉呢？架构真的很重要，致那些因为架构死去的项目，真正的项目应该死在实践中，因为架构的问题最终变得不可收拾的，这件事情本身就是可耻的。好了，今天就说这么多了。\\n\"",
            "url": "\"/posts/3356910090/\"",
            "date": "\"2015-03-27\""
        },
        
        {
            "title": "\"使用 Love2D 引擎开发贪吃蛇游戏\"",
            "content": "\"今天来介绍博主最近捣腾的一个小游戏“贪吃蛇”。“贪吃蛇”这个游戏相信大家都不会感到陌生吧。今天博主将通过Love2D这款游戏引擎来为大家实现一个简单的贪吃蛇游戏,在本篇文章当中我们将会涉及到“贪吃蛇”的基本算法、Lua 语言编程等基本的内容，希望能够对大家开发类似的游戏提供借鉴和思考，文章中如有不足之处，还希望大家能够谅解，因为博主的游戏开发基本就是这样慢慢摸索着学习，所以难免会有不足的地方。\\n游戏算法 我们首先来看看贪吃蛇是怎么移动的？ 通过这四张图的演示，我们可以发现这样一个规律：\\n蛇的移动其实是将蛇身体的最后一个元素移动到第一个元素的位置\\n那么完成这样一个工作需要两个步骤：\\n1、将在蛇头位置插入一个新的元素 2、移除蛇尾位置的最后一个元素\\n好了，了解了蛇的移动后我们再来考虑一个问题，怎样判断蛇吃到了食物？思路和蛇的移动类似，主要考虑在蛇头插入的这个元素和食物的关系，如果这个元素的坐标和食物的坐标是相同的，那么就可以认为蛇吃到了食物，此时蛇的身体应该是变长的，所以只要在蛇头位置插入一个元素就可以了。反之，如果蛇没有吃到食物，那么蛇应该是移动的，所以就可以按照移动的方法来处理了。那么在蛇头位置插入的这个元素该如何确定呢？我们来看下面这段程序：\\n--计算下一个目标点 function getNextPoint() --计算下一个目标点 snake = {} if (dir == 0) then snake.x = snakes[1].x snake.y = snakes[1].y - 20 end if (dir == 1) then snake.x = snakes[1].x snake.y = snakes[1].y + 20 end if (dir == 2) then snake.x = snakes[1].x - 20 snake.y = snakes[1].y end if (dir == 3) then snake.x = snakes[1].x + 20 snake.y = snakes[1].y end return snake end 这里定义了 getNextPoint()的方法，目的是计算在蛇头位置添加的下一个元素，这里我们注意到根据蛇的移动方向(dir)的不同，其中 0 表示上、1 表示下、2 表示左、3 表示右，计算出下一个元素的位置，因为在这个游戏中网格大小是 20，所以这里可以直接根据坐标来计算一个元素的位置。snakes 是一个 table，保存的是当前的蛇的全部元素的坐标。通过维护这个 table，我们就可以利用绘图的函数绘制出蛇的身体，这样蛇就可以移动起来了。我们来看看蛇是怎样移动的：\\n--核心算法——蛇的移动 function SnakeUpdate() --获取元素个数 local n = table.maxn(snakes) if (table.maxn(snakes) \\u0026gt; 0) then if (getNextPoint().x == foodX and getNextPoint().y == foodY) then --将下一个目标点的位置插入表中 table.insert(snakes, 1, getNextPoint()) --将食物状态设置为BeEated foodState=\\u0026#34;BeEated\\u0026#34; else --将下一个目标点的位置插入表中 table.insert(snakes, 1, getNextPoint()) --移除最后一个元素 table.remove(snakes,n+1) end end end 在这里我们定义了一个 foodState 变量以保存食物的状态，当食物的状态为 BeEated 的时候表示食物被蛇吃掉了，此时应该重新生成一个食物的坐标，此时事物的状态将变成 WaitToEat。食物的坐标保存在 foodX 和 foodY 这两个变量中，大家可以到完整的代码中去查看。\\n游戏状态 我们知道蛇碰到四周墙壁的时候就会死亡，此时游戏结束。这个比较简单，只要判断蛇头的坐标和屏幕的关系就可以了。因为在这个游戏中屏幕的尺寸为 640X640，所以判断游戏是否结束的代码可以这样写：\\n--判断游戏状态 if(snakes[1].x \\u0026lt;= 0 or snakes[1].x \\u0026gt;= 640 or snakes[1].y \\u0026lt;= 0 or snakes[1].y \\u0026gt;= 640) then gameState = 0 else gameState = 1 end 这里 gameState 为 0 表示游戏结束，gameState 为 1 表示游戏正常进行。\\n完整代码 在完成了这些核心的算法以后，剩下的事情就交给 Love2D 引擎来绘制吧，最后给出完整的程序代码：\\n--定义窗口宽度和高度 local w\\t= 640 local h\\t= 640 --定义网格单元大小 local unitSize = 20; --方块的初始位置 local initX\\t= 320 local initY\\t= 320 --移动方向 local dir = 1 --贪吃蛇集合 local snakes = {} --食物状态 --WaitToEat：绘制食物 --BeEated：随机生成食物 local foodState = \\u0026#34;WaitToEat\\u0026#34; --游戏状态 --0：游戏结束 --1：游戏正常 local gameState = 1 --食物的位置 local foodX = 0 local foodY = 0 --Love2D加载事件 function love.load() --设置窗口标题 love.window.setTitle(\\u0026#34;Love2D-贪吃蛇游戏\\u0026#34;) --设置窗口大小 love.window.setMode(w,h) --定义字体 local myFont = love.graphics.newFont(30) --设置字体 love.graphics.setFont(myFont) --设置背景色 love.graphics.setBackgroundColor(255,255,255,255) --设置线条类型为平滑 love.graphics.setLineStyle(\\u0026#34;smooth\\u0026#34;) --设置线宽 love.graphics.setLineWidth(0.1) --蛇的初始化(蛇的长度为5) for i=1,5 do local snake = { } snake.x = initX + (i-1) * 20 snake.y = initY snakes[i] = snake end --食物初始化 foodX = love.math.random(32-1)*20 foodY = love.math.random(32-1)*20 end --Love2D绘制事件 function love.draw() --绘制竖线 love.graphics.setColor(0,0,0,255) for i = 0, w, unitSize do love.graphics.line(0,i,h,i) end --绘制横线 for j = 0, h, unitSize do love.graphics.line(j,0,j,w) end --绘制蛇 for i = 1,table.maxn(snakes) do love.graphics.setColor(0,0,255,255) love.graphics.rectangle(\\u0026#34;fill\\u0026#34;,snakes[i].x,snakes[i].y,20,20) end --绘制食物 if(foodState == \\u0026#34;WaitToEat\\u0026#34;) then love.graphics.setColor(255,0,0,255) love.graphics.rectangle(\\u0026#34;fill\\u0026#34;,foodX,foodY,20,20) end --如果游戏结束则显示GameOver if(gameState == 0) then love.graphics.setColor(255,0,0,255) love.graphics.print(\\u0026#34;Game Over\\u0026#34;,250,300) end end -- function love.update(dt) --判断游戏状态 if (snakes[1].x \\u0026lt;= 0 or snakes[1].x \\u0026gt;= 640 or snakes[1].y \\u0026lt;= 0 or snakes[1].y \\u0026gt;= 640) then gameState = 0 else gameState = 1 end --如果游戏状态为正常 if (gameState == 1) then SnakeUpdate() FoodUpdate() end end --核心算法——蛇的移动 function SnakeUpdate(dt) --获取元素个数 local n = table.maxn(snakes) if(table.maxn(snakes) \\u0026gt; 0) then if(getNextPoint().x == foodX and getNextPoint().y == foodY) then --将下一个目标点的位置插入表中 table.insert(snakes, 1, getNextPoint()) --将食物状态设置为BeEated foodState=\\u0026#34;BeEated\\u0026#34; else --将下一个目标点的位置插入表中 table.insert(snakes, 1, getNextPoint()) --移除最后一个元素 table.remove(snakes,n+1) end end end --随机生成食物 function FoodUpdate() --如果食物被蛇吃掉则重新生成食物 if(foodState == \\u0026#34;BeEated\\u0026#34;) then foodX=love.math.random(32-1)*20 foodY=love.math.random(32-1)*20 foodState = \\u0026#34;WaitToEat\\u0026#34; end end --根据玩家按下的键位定义不同的方向 function love.keypressed(key) if (key == \\u0026#34;a\\u0026#34;) then dir = 2 end if (key == \\u0026#34;d\\u0026#34;) then dir = 3 end if (key == \\u0026#34;w\\u0026#34;) then dir = 0 end if (key==\\u0026#34;s\\u0026#34;) then dir = 1 end end --计算下一个目标点 function getNextPoint() --计算下一个目标点 local snake = {} if(dir == 0) then snake.x = snakes[1].x snake.y = snakes[1].y - 20 end if(dir == 1) then snake.x = snakes[1].x snake.y = snakes[1].y + 20 end if(dir == 2) then snake.x=snakes[1].x - 20 snake.y=snakes[1].y end if(dir == 3) then snake.x = snakes[1].x + 20 snake.y = snakes[1].y end return snake end 将代码压缩成.love 文件后就可以运行了，我们来看看最终的效果：\\n本文的项目作为开源项目托管在 Github 上，可以通过Github来获取项目源代码。谢谢大家，今天的内容就是这样了。\\n\"",
            "url": "\"/posts/426338252/\"",
            "date": "\"2015-03-10\""
        },
        
    ];
</script> </header>

        
        <main class="main-layout">















<div class="home">
  
    







<div class="banner half" id="main-banner">
    <h1 class="title">你好，欢迎来到元视角</h1>
    <div class="subtitle">
        <span class="text">
            纵有疾风起，人生不言弃
        </span>
    </div>
    
</div>


<style>
.banner {
    height: 300px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    animation: fade-up 0.6s 0.1s backwards;
    transition: height 0.3s;
}

.banner.full {
    opacity: 0;
    height: calc(100vh - 70px);
    padding-bottom: 100px;
    animation: fade-up 0.6s 0.5s forwards;
}

.banner.full .subtitle {
    opacity: 0;
    animation: fade-up-opacity 0.8s 0.5s forwards;
}

.banner .title {
    font-family: "Site Title";
    font-weight: bold;
    font-size: 2.75rem;
}

.banner .subtitle {
    width: 80%;
    font-size: 1.25rem;
    opacity: 0.8;
    animation: fade-up-opacity 0.6s 0.1s backwards;
}

.banner .subtitle .text {
    text-align: center;
    overflow: hidden;
    text-overflow: ellipsis;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
}

.banner .icon-up {
    font-size: 20px;
    position: absolute;
    bottom: 60px;
    left: calc(50% - 10px);
    transform: rotate(180deg);
    animation: moveDown 2s ease-in-out infinite;
    cursor: pointer;
}

.banner-page {
    position: relative;
    display: flex;
    flex-direction: column;
    padding: 2rem;
    min-height: 380px;
    background-size: cover;
}

.banner-page .top {
    display: flex;
    flex-direction: row;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 2rem;
}

.banner-page .top .title {
    display: flex;
    flex-direction: column;
}

.banner-page .top .title .title-small {
    color: var(--main-font-second-color);
    font-size: 0.875rem;
}

.banner-page .top .title .title-big {
    font-size: 2.25rem;
    font-weight: bold;
    line-height: 1.2;
    margin-top: 12px;
}

.banner-page .footer {
    display: flex;
    flex-direction: row;
    align-items: center;
    justify-content: space-between;
    margin-top: auto;
}

.banner-page .footer .footer-left {
    margin-top: auto;
    color: var(--main-font-second-color);
    opacity: 0.8;
}

.banner-page.image {
    color: #fff !important;
}

.banner-page.image .top .title-small {
    color: #fff;
    opacity: 0.6;
}

.banner-page.image .footer .footer-left {
    color: #fff;
}

.banner-page.image .footer .iconfont {
    color: #fff !important;
}

@media (max-width: 1200px) {
    .banner-page {
        min-height: 300px;
    }
}

@media (max-width: 768px) {
    .banner {
        align-items: flex-start;
        height: 240px;
    }
    
    .banner .title {
        font-size: 2.25rem;
    }
    
    .banner .subtitle {
        height: 50px;
        font-size: 1.125rem;
        margin-left: 8px;
    }
    
    .banner .subtitle .text {
        text-align: left;
    }
    
    .banner-page {
        min-height: 260px;
    }
    
    .banner-page .top-right,
    .banner-page .footer-right {
        display: none;
    }
}

@keyframes fade-up {
    from {
        opacity: 0;
        transform: translateY(20px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

@keyframes fade-up-opacity {
    from {
        opacity: 0;
        transform: translateY(20px);
    }
    to {
        opacity: 0.8;
        transform: translateY(0);
    }
}

@keyframes moveDown {
    0%, 100% {
        transform: translateY(0) rotate(180deg);
    }
    50% {
        transform: translateY(10px) rotate(180deg);
    }
}
</style> 
  
  
  <div class="home-content">
    <div class="posts-content">
      
      
      



<div class="type-bar s-card hover">
  <div class="all-type">
    
    

    
    <a href="/" class="type-item choose">首页</a>

    
    
      
        
          <a href="/pages/categories/%e5%8d%95%e6%9c%ba%e6%b8%b8%e6%88%8f" class="type-item">
            单机游戏
          </a>
        
      
        
          <a href="/pages/categories/%e6%b8%b8%e6%88%8f%e5%bc%80%e5%8f%91" class="type-item">
            游戏开发
          </a>
        
      
        
          <a href="/pages/categories/%e7%94%9f%e6%b4%bb%e6%84%9f%e6%82%9f" class="type-item">
            生活感悟
          </a>
        
      
        
          <a href="/pages/categories/%e7%bc%96%e7%a8%8b%e8%af%ad%e8%a8%80" class="type-item">
            编程语言
          </a>
        
      
        
          <a href="/pages/categories/%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0" class="type-item">
            读书笔记
          </a>
        
      
    
  </div>

  
  <a href="/pages/categories" class="more-type">
    <i class="iconfont icon-arrow-right"></i>
    更多
  </a>
</div> 
      
      
      
      



<div class="post-list ">
    
    <article class="post-item s-card">
        
        
        
        <div class="content">
            
            <h2 class="title">
                <a href="/posts/ne-zha-2/">命运、偏见与自由：《魔童之哪吒闹海》的终极抗争</a>
            </h2>
            
            
            <div class="summary">
                
                    春节档爆款动画《哪吒之魔童闹海》不仅延续了《魔童降世》的精彩叙事，更将主题升华至对身份认同、权力游戏与自由秩序的深刻探讨。本片通过哪吒与敖丙的劫后重生，揭示了偏见、制度失范与个体抗争的复杂关系。文章深入剖析了影片中的权力结构、种族偏见与道德困境，结合历史与哲学视角，探讨了人类文明进程中的永恒矛盾。从 “我命由我不由天” 到打破天元鼎的桎梏，《哪吒》系列以其燃爆的剧情与深刻的内涵，成为一部关于自由与反抗的史诗。如果你热爱动画电影、神话改编或社会议题探讨，这篇深度解析将为你带来全新的观影视角与思想启发。
                
            </div>
            
            
            <div class="meta">
                
                <div class="date">
                    <i class="iconfont icon-calendar"></i>
                    <span>2025-02-06</span>
                </div>
                
                
                
                <div class="categories">
                    <i class="iconfont icon-folder"></i>
                    
                    <a href="/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F">生活感悟</a>
                    
                </div>
                
                
                
                
                <div class="tags">
                    <i class="iconfont icon-tag"></i>
                    
                    <a href="/tags/%E5%BD%B1%E8%AF%84">影评</a>
                    
                    <a href="/tags/%E5%93%AA%E5%90%92">哪吒</a>
                    
                    <a href="/tags/%E5%B0%81%E7%A5%9E">封神</a>
                    
                    <a href="/tags/%E5%8A%A8%E6%BC%AB">动漫</a>
                    
                </div>
                
            </div>
        </div>
    </article>
    
</div> 
      
      
      
      







<div class="pagination">
  
</div> 
    </div>
    
    
    <aside class="main-aside">
<div class="hello s-card weidgets">
  <span class="tip" >中午好，吃饱了精神好！</span>
  <div class="content">
    <div class="site-logo">
      <div class="avatar">
    <img src="/images/avatar.jpg" />
</div>
    </div>
    <span class="site-desc"></span>
  </div>
  <div class="info">
    <div class="name">
      <span class="author">飞鸿踏雪</span>
      <span class="desc">纵有疾风起，人生不言弃</span>
    </div>
    <div class="link">
      <a href="https://github.com/imsyy/" target="_blank" class="social-link">
        <i class="iconfont icon-github"></i>
      </a>
      <a href="mailto:one@imsyy.top" target="_blank" class="social-link">
        <i class="iconfont icon-email"></i>
      </a>
    </div>
  </div>
</div>
<div class="sticky"> 
<div class="aside-countdown s-card weidgets">
  <div class="card-title">
    <i class="fas fa-hourglass-half"></i>
    <span>倒计时</span>
  </div>
  <div class="card-content">
    
  </div>
</div> 
<div class="tags-cloud s-card weidgets">
  <div class="title">
    <i class="iconfont icon-hashtag"></i>
    <span class="title-name">热门标签</span>
  </div>
  <div class="all-tags">
    
        
          <a href="/tags/.net/" class="tags">
            <span class="name">.NET</span>
            <sup class="num">1</sup>
          </a>
        
      
        
          <a href="/tags/.net-core/" class="tags">
            <span class="name">.NET Core</span>
            <sup class="num">2</sup>
          </a>
        
      
        
          <a href="/tags/agent/" class="tags">
            <span class="name">Agent</span>
            <sup class="num">1</sup>
          </a>
        
      
        
          <a href="/tags/function-calling/" class="tags">
            <span class="name">Function Calling</span>
            <sup class="num">1</sup>
          </a>
        
      
        
          <a href="/tags/hangfire/" class="tags">
            <span class="name">Hangfire</span>
            <sup class="num">1</sup>
          </a>
        
      
        
          <a href="/tags/hashset/" class="tags">
            <span class="name">HashSet</span>
            <sup class="num">1</sup>
          </a>
        
      
        
          <a href="/tags/http/" class="tags">
            <span class="name">HTTP</span>
            <sup class="num">1</sup>
          </a>
        
      
        
          <a href="/tags/httpclient/" class="tags">
            <span class="name">HttpClient</span>
            <sup class="num">1</sup>
          </a>
        
      
        
          <a href="/tags/k-means/" class="tags">
            <span class="name">K-Means</span>
            <sup class="num">1</sup>
          </a>
        
      
        
          <a href="/tags/kindle/" class="tags">
            <span class="name">Kindle</span>
            <sup class="num">1</sup>
          </a>
        
      
        
          <a href="/tags/lambda/" class="tags">
            <span class="name">Lambda</span>
            <sup class="num">1</sup>
          </a>
        
      
        
          <a href="/tags/linq/" class="tags">
            <span class="name">Linq</span>
            <sup class="num">1</sup>
          </a>
        
      
        
          <a href="/tags/linux/" class="tags">
            <span class="name">Linux</span>
            <sup class="num">1</sup>
          </a>
        
      
        
          <a href="/tags/love2d/" class="tags">
            <span class="name">Love2D</span>
            <sup class="num">1</sup>
          </a>
        
      
        
          <a href="/tags/mcp/" class="tags">
            <span class="name">MCP</span>
            <sup class="num">1</sup>
          </a>
        
      
        
          <a href="/tags/mock/" class="tags">
            <span class="name">Mock</span>
            <sup class="num">1</sup>
          </a>
        
      
        
          <a href="/tags/mono/" class="tags">
            <span class="name">Mono</span>
            <sup class="num">1</sup>
          </a>
        
      
        
          <a href="/tags/rpg/" class="tags">
            <span class="name">RPG</span>
            <sup class="num">1</sup>
          </a>
        
      
        
          <a href="/tags/scikit-learn/" class="tags">
            <span class="name">Scikit-Learn</span>
            <sup class="num">1</sup>
          </a>
        
      
        
          <a href="/tags/semantic-kernel/" class="tags">
            <span class="name">Semantic Kernel</span>
            <sup class="num">1</sup>
          </a>
        
      
        
          <a href="/tags/signalr/" class="tags">
            <span class="name">SignalR</span>
            <sup class="num">1</sup>
          </a>
        
      
        
          <a href="/tags/unity3d/" class="tags">
            <span class="name">Unity3D</span>
            <sup class="num">1</sup>
          </a>
        
      
        
          <a href="/tags/%E4%BA%BA%E8%84%B8%E5%88%86%E7%B1%BB/" class="tags">
            <span class="name">人脸分类</span>
            <sup class="num">1</sup>
          </a>
        
      
        
          <a href="/tags/%E4%BB%99%E5%89%91%E5%A5%87%E4%BE%A0%E4%BC%A0/" class="tags">
            <span class="name">仙剑奇侠传</span>
            <sup class="num">1</sup>
          </a>
        
      
        
          <a href="/tags/%E4%BD%8E%E4%BB%A3%E7%A0%81/" class="tags">
            <span class="name">低代码</span>
            <sup class="num">1</sup>
          </a>
        
      
        
          <a href="/tags/%E5%8A%A8%E6%BC%AB/" class="tags">
            <span class="name">动漫</span>
            <sup class="num">1</sup>
          </a>
        
      
        
          <a href="/tags/%E5%93%AA%E5%90%92/" class="tags">
            <span class="name">哪吒</span>
            <sup class="num">1</sup>
          </a>
        
      
        
          <a href="/tags/%E5%B0%81%E7%A5%9E/" class="tags">
            <span class="name">封神</span>
            <sup class="num">1</sup>
          </a>
        
      
        
          <a href="/tags/%E5%BD%B1%E8%AF%84/" class="tags">
            <span class="name">影评</span>
            <sup class="num">1</sup>
          </a>
        
      
        
          <a href="/tags/%E6%84%9F%E6%82%9F/" class="tags">
            <span class="name">感悟</span>
            <sup class="num">1</sup>
          </a>
        
      
        
          <a href="/tags/%E6%89%A9%E5%B1%95/" class="tags">
            <span class="name">扩展</span>
            <sup class="num">1</sup>
          </a>
        
      
        
          <a href="/tags/%E6%95%B0%E6%8D%AE/" class="tags">
            <span class="name">数据</span>
            <sup class="num">1</sup>
          </a>
        
      
        
          <a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" class="tags">
            <span class="name">机器学习</span>
            <sup class="num">1</sup>
          </a>
        
      
        
          <a href="/tags/%E6%B8%B8%E6%88%8F/" class="tags">
            <span class="name">游戏</span>
            <sup class="num">2</sup>
          </a>
        
      
        
          <a href="/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/" class="tags">
            <span class="name">游戏开发</span>
            <sup class="num">1</sup>
          </a>
        
      
        
          <a href="/tags/%E6%BA%90%E7%A0%81/" class="tags">
            <span class="name">源码</span>
            <sup class="num">1</sup>
          </a>
        
      
        
          <a href="/tags/%E7%88%B1%E6%83%85/" class="tags">
            <span class="name">爱情</span>
            <sup class="num">1</sup>
          </a>
        
      
        
          <a href="/tags/%E7%8A%B6%E6%80%81/" class="tags">
            <span class="name">状态</span>
            <sup class="num">1</sup>
          </a>
        
      
        
          <a href="/tags/%E7%AE%A1%E9%81%93/" class="tags">
            <span class="name">管道</span>
            <sup class="num">1</sup>
          </a>
        
      
        
          <a href="/tags/%E7%BC%96%E7%A8%8B/" class="tags">
            <span class="name">编程</span>
            <sup class="num">2</sup>
          </a>
        
      
        
          <a href="/tags/%E8%81%9A%E7%B1%BB/" class="tags">
            <span class="name">聚类</span>
            <sup class="num">1</sup>
          </a>
        
      
        
          <a href="/tags/%E8%A1%8C%E4%B8%9A/" class="tags">
            <span class="name">行业</span>
            <sup class="num">1</sup>
          </a>
        
      
        
          <a href="/tags/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91/" class="tags">
            <span class="name">表达式树</span>
            <sup class="num">1</sup>
          </a>
        
      
        
          <a href="/tags/%E8%AF%BB%E4%B9%A6/" class="tags">
            <span class="name">读书</span>
            <sup class="num">1</sup>
          </a>
        
      
        
          <a href="/tags/%E8%B4%AA%E5%90%83%E8%9B%87/" class="tags">
            <span class="name">贪吃蛇</span>
            <sup class="num">1</sup>
          </a>
        
      
        
          <a href="/tags/%E8%B7%A8%E5%B9%B3%E5%8F%B0/" class="tags">
            <span class="name">跨平台</span>
            <sup class="num">1</sup>
          </a>
        
      
        
          <a href="/tags/%E8%BF%81%E7%A7%BB/" class="tags">
            <span class="name">迁移</span>
            <sup class="num">1</sup>
          </a>
        
      
        
          <a href="/tags/%E9%9D%A2%E8%AF%95/" class="tags">
            <span class="name">面试</span>
            <sup class="num">1</sup>
          </a>
        
      
  </div>
  <a href="/pages/tags" class="more-tags">查看全部</a>
</div><div class="site-data s-card weidgets">
    <div class="title">
      <i class="iconfont icon-chart"></i>
      <span class="title-name">站点数据</span>
    </div>
    <div class="all-data">
      <div class="data-item">
        <span class="name">
          <i class="iconfont icon-article"></i>
          文章总数
        </span>
        <span class="num">277 篇</span>
      </div>
      <div class="data-item">
        <span class="name">
          <i class="iconfont icon-date"></i>
          建站天数
        </span>
        <span class="num">200 天</span>
      </div>
      <div class="data-item">
        <span class="name">
          <i class="iconfont icon-visibility"></i>
          总访问量
        </span>
        <span class="num" id="busuanzi_value_site_pv">0</span>
      </div>
      <div class="data-item">
        <span class="name">
          <i class="iconfont icon-account"></i>
          总访客数
        </span>
        <span class="num" id="busuanzi_value_site_uv">0</span>
      </div>
    </div>
  </div></div>
  </aside>
  <style>
  .main-aside {
    padding-left: 1rem;
    display: flex;
    flex-direction: column;
    animation: fade-up 0.6s 0.3s backwards;
    .weidgets {
      padding: 18px;
      margin-bottom: 1rem;
      :deep(.title) {
        margin-bottom: 12px;
        font-weight: bold;
        display: flex;
        align-items: center;
        opacity: 0.75;
        .iconfont {
          opacity: 0.6;
          margin-right: 6px;
        }
        .title-name {
          opacity: 0.8;
        }
      }
    }
    .sticky {
      position: sticky;
      top: calc(60px + 1rem);
      .weidgets {
        animation: fade-up 0.6s 0.4s backwards;
        &:last-child {
          margin-bottom: 0;
        }
      }
    }
  }
  </style>
  
  </div>
</div>


<script>
document.addEventListener('DOMContentLoaded', function() {
  const scrollY = localStorage.getItem('lastScrollY');
  if (scrollY) {
    window.scrollTo({
      top: parseInt(scrollY),
      behavior: 'smooth'
    });
    localStorage.removeItem('lastScrollY');
  }
});

window.addEventListener('beforeunload', function() {
  localStorage.setItem('lastScrollY', window.scrollY.toString());
});
</script>

        </main>

        <div class="control-panel">
    <div class="control-mask"></div>
    <div class="control-content">
        <div class="control-header">
            <div class="control-title">
                <i class="iconfont icon-dashboard"></i>
                <span>中控台</span>
            </div>
            <div class="control-close">
                <i class="iconfont icon-close"></i>
            </div>
        </div>
        <div class="control-body">
            
            <div class="control-group">
                <div class="group-title">主题设置</div>
                <div class="group-content">
                    
                    <div class="control-item">
                        <div class="item-title">主题模式</div>
                        <div class="item-content">
                            <div class="theme-switch">
                                <div class="switch-item" data-theme="light">
                                    <i class="iconfont icon-sun"></i>
                                </div>
                                <div class="switch-item" data-theme="dark">
                                    <i class="iconfont icon-moon"></i>
                                </div>
                                <div class="switch-item" data-theme="auto">
                                    <i class="iconfont icon-auto"></i>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="control-item">
                        <div class="item-title">主题色</div>
                        <div class="item-content">
                            <div class="color-switch">
                                
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div> <div class="background">
    
    <div class="bg-mask"></div>
    
    
    <div class="bg-image" style="background-image: url('https://tuapi.eees.cc/api.php?category=%7bdongman,fengjing%7d&amp;type=302')"></div>
    
    
    
</div> 

<style>
    .background {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: -2;
      &.patterns {
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='192' height='192' viewBox='0 0 192 192'%3E%3Cpath fill='%23494849' fill-opacity='0.08' d='M192 15v2a11 11 0 0 0-11 11c0 1.94 1.16 4.75 2.53 6.11l2.36 2.36a6.93 6.93 0 0 1 1.22 7.56l-.43.84a8.08 8.08 0 0 1-6.66 4.13H145v35.02a6.1 6.1 0 0 0 3.03 4.87l.84.43c1.58.79 4 .4 5.24-.85l2.36-2.36a12.04 12.04 0 0 1 7.51-3.11 13 13 0 1 1 .02 26 12 12 0 0 1-7.53-3.11l-2.36-2.36a4.93 4.93 0 0 0-5.24-.85l-.84.43a6.1 6.1 0 0 0-3.03 4.87V143h35.02a8.08 8.08 0 0 1 6.66 4.13l.43.84a6.91 6.91 0 0 1-1.22 7.56l-2.36 2.36A10.06 10.06 0 0 0 181 164a11 11 0 0 0 11 11v2a13 13 0 0 1-13-13 12 12 0 0 1 3.11-7.53l2.36-2.36a4.93 4.93 0 0 0 .85-5.24l-.43-.84a6.1 6.1 0 0 0-4.87-3.03H145v35.02a8.08 8.08 0 0 1-4.13 6.66l-.84.43a6.91 6.91 0 0 1-7.56-1.22l-2.36-2.36A10.06 10.06 0 0 0 124 181a11 11 0 0 0-11 11h-2a13 13 0 0 1 13-13c2.47 0 5.79 1.37 7.53 3.11l2.36 2.36a4.94 4.94 0 0 0 5.24.85l.84-.43a6.1 6.1 0 0 0 3.03-4.87V145h-35.02a8.08 8.08 0 0 1-6.66-4.13l-.43-.84a6.91 6.91 0 0 1 1.22-7.56l2.36-2.36A10.06 10.06 0 0 0 107 124a11 11 0 0 0-22 0c0 1.94 1.16 4.75 2.53 6.11l2.36 2.36a6.93 6.93 0 0 1 1.22 7.56l-.43.84a8.08 8.08 0 0 1-6.66 4.13H49v35.02a6.1 6.1 0 0 0 3.03 4.87l.84.43c1.58.79 4 .4 5.24-.85l2.36-2.36a12.04 12.04 0 0 1 7.51-3.11A13 13 0 0 1 81 192h-2a11 11 0 0 0-11-11c-1.94 0-4.75 1.16-6.11 2.53l-2.36 2.36a6.93 6.93 0 0 1-7.56 1.22l-.84-.43a8.08 8.08 0 0 1-4.13-6.66V145H11.98a6.1 6.1 0 0 0-4.87 3.03l-.43.84c-.79 1.58-.4 4 .85 5.24l2.36 2.36a12.04 12.04 0 0 1 3.11 7.51A13 13 0 0 1 0 177v-2a11 11 0 0 0 11-11c0-1.94-1.16-4.75-2.53-6.11l-2.36-2.36a6.93 6.93 0 0 1-1.22-7.56l.43-.84a8.08 8.08 0 0 1 6.66-4.13H47v-35.02a6.1 6.1 0 0 0-3.03-4.87l-.84-.43c-1.59-.8-4-.4-5.24.85l-2.36 2.36A12 12 0 0 1 28 109a13 13 0 1 1 0-26c2.47 0 5.79 1.37 7.53 3.11l2.36 2.36a4.94 4.94 0 0 0 5.24.85l.84-.43A6.1 6.1 0 0 0 47 84.02V49H11.98a8.08 8.08 0 0 1-6.66-4.13l-.43-.84a6.91 6.91 0 0 1 1.22-7.56l2.36-2.36A10.06 10.06 0 0 0 11 28 11 11 0 0 0 0 17v-2a13 13 0 0 1 13 13c0 2.47-1.37 5.79-3.11 7.53l-2.36 2.36a4.94 4.94 0 0 0-.85 5.24l.43.84A6.1 6.1 0 0 0 11.98 47H47V11.98a8.08 8.08 0 0 1 4.13-6.66l.84-.43a6.91 6.91 0 0 1 7.56 1.22l2.36 2.36A10.06 10.06 0 0 0 68 11 11 11 0 0 0 79 0h2a13 13 0 0 1-13 13 12 12 0 0 1-7.53-3.11l-2.36-2.36a4.93 4.93 0 0 0-5.24-.85l-.84.43A6.1 6.1 0 0 0 49 11.98V47h35.02a8.08 8.08 0 0 1 6.66 4.13l.43.84a6.91 6.91 0 0 1-1.22 7.56l-2.36 2.36A10.06 10.06 0 0 0 85 68a11 11 0 0 0 22 0c0-1.94-1.16-4.75-2.53-6.11l-2.36-2.36a6.93 6.93 0 0 1-1.22-7.56l.43-.84a8.08 8.08 0 0 1 6.66-4.13H143V11.98a6.1 6.1 0 0 0-3.03-4.87l-.84-.43c-1.59-.8-4-.4-5.24.85l-2.36 2.36A12 12 0 0 1 124 13a13 13 0 0 1-13-13h2a11 11 0 0 0 11 11c1.94 0 4.75-1.16 6.11-2.53l2.36-2.36a6.93 6.93 0 0 1 7.56-1.22l.84.43a8.08 8.08 0 0 1 4.13 6.66V47h35.02a6.1 6.1 0 0 0 4.87-3.03l.43-.84c.8-1.59.4-4-.85-5.24l-2.36-2.36A12 12 0 0 1 179 28a13 13 0 0 1 13-13zM84.02 143a6.1 6.1 0 0 0 4.87-3.03l.43-.84c.8-1.59.4-4-.85-5.24l-2.36-2.36A12 12 0 0 1 83 124a13 13 0 1 1 26 0c0 2.47-1.37 5.79-3.11 7.53l-2.36 2.36a4.94 4.94 0 0 0-.85 5.24l.43.84a6.1 6.1 0 0 0 4.87 3.03H143v-35.02a8.08 8.08 0 0 1 4.13-6.66l.84-.43a6.91 6.91 0 0 1 7.56 1.22l2.36 2.36A10.06 10.06 0 0 0 164 107a11 11 0 0 0 0-22c-1.94 0-4.75 1.16-6.11 2.53l-2.36 2.36a6.93 6.93 0 0 1-7.56 1.22l-.84-.43a8.08 8.08 0 0 1-4.13-6.66V49h-35.02a6.1 6.1 0 0 0-4.87 3.03l-.43.84c-.79 1.58-.4 4 .85 5.24l2.36 2.36a12.04 12.04 0 0 1 3.11 7.51A13 13 0 1 1 83 68a12 12 0 0 1 3.11-7.53l2.36-2.36a4.93 4.93 0 0 0 .85-5.24l-.43-.84A6.1 6.1 0 0 0 84.02 49H49v35.02a8.08 8.08 0 0 1-4.13 6.66l-.84.43a6.91 6.91 0 0 1-7.56-1.22l-2.36-2.36A10.06 10.06 0 0 0 28 85a11 11 0 0 0 0 22c1.94 0 4.75-1.16 6.11-2.53l2.36-2.36a6.93 6.93 0 0 1 7.56-1.22l.84.43a8.08 8.08 0 0 1 4.13 6.66V143h35.02z'%3E%3C/path%3E%3C/svg%3E");
      }
      &.dark {
        &.patterns {
          background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='192' height='192' viewBox='0 0 192 192'%3E%3Cpath fill='%23fcfcfc' fill-opacity='0.08' d='M192 15v2a11 11 0 0 0-11 11c0 1.94 1.16 4.75 2.53 6.11l2.36 2.36a6.93 6.93 0 0 1 1.22 7.56l-.43.84a8.08 8.08 0 0 1-6.66 4.13H145v35.02a6.1 6.1 0 0 0 3.03 4.87l.84.43c1.58.79 4 .4 5.24-.85l2.36-2.36a12.04 12.04 0 0 1 7.51-3.11 13 13 0 1 1 .02 26 12 12 0 0 1-7.53-3.11l-2.36-2.36a4.93 4.93 0 0 0-5.24-.85l-.84.43a6.1 6.1 0 0 0-3.03 4.87V143h35.02a8.08 8.08 0 0 1 6.66 4.13l.43.84a6.91 6.91 0 0 1-1.22 7.56l-2.36 2.36A10.06 10.06 0 0 0 181 164a11 11 0 0 0 11 11v2a13 13 0 0 1-13-13 12 12 0 0 1 3.11-7.53l2.36-2.36a4.93 4.93 0 0 0 .85-5.24l-.43-.84a6.1 6.1 0 0 0-4.87-3.03H145v35.02a8.08 8.08 0 0 1-4.13 6.66l-.84.43a6.91 6.91 0 0 1-7.56-1.22l-2.36-2.36A10.06 10.06 0 0 0 124 181a11 11 0 0 0-11 11h-2a13 13 0 0 1 13-13c2.47 0 5.79 1.37 7.53 3.11l2.36 2.36a4.94 4.94 0 0 0 5.24.85l.84-.43a6.1 6.1 0 0 0 3.03-4.87V145h-35.02a8.08 8.08 0 0 1-6.66-4.13l-.43-.84a6.91 6.91 0 0 1 1.22-7.56l2.36-2.36A10.06 10.06 0 0 0 107 124a11 11 0 0 0-22 0c0 1.94 1.16 4.75 2.53 6.11l2.36 2.36a6.93 6.93 0 0 1 1.22 7.56l-.43.84a8.08 8.08 0 0 1-6.66 4.13H49v35.02a6.1 6.1 0 0 0 3.03 4.87l.84.43c1.58.79 4 .4 5.24-.85l2.36-2.36a12.04 12.04 0 0 1 7.51-3.11A13 13 0 0 1 81 192h-2a11 11 0 0 0-11-11c-1.94 0-4.75 1.16-6.11 2.53l-2.36 2.36a6.93 6.93 0 0 1-7.56 1.22l-.84-.43a8.08 8.08 0 0 1-4.13-6.66V145H11.98a6.1 6.1 0 0 0-4.87 3.03l-.43.84c-.79 1.58-.4 4 .85 5.24l2.36 2.36a12.04 12.04 0 0 1 3.11 7.51A13 13 0 0 1 0 177v-2a11 11 0 0 0 11-11c0-1.94-1.16-4.75-2.53-6.11l-2.36-2.36a6.93 6.93 0 0 1-1.22-7.56l.43-.84a8.08 8.08 0 0 1 6.66-4.13H47v-35.02a6.1 6.1 0 0 0-3.03-4.87l-.84-.43c-1.59-.8-4-.4-5.24.85l-2.36 2.36A12 12 0 0 1 28 109a13 13 0 1 1 0-26c2.47 0 5.79 1.37 7.53 3.11l2.36 2.36a4.94 4.94 0 0 0 5.24.85l.84-.43A6.1 6.1 0 0 0 47 84.02V49H11.98a8.08 8.08 0 0 1-6.66-4.13l-.43-.84a6.91 6.91 0 0 1 1.22-7.56l2.36-2.36A10.06 10.06 0 0 0 11 28 11 11 0 0 0 0 17v-2a13 13 0 0 1 13 13c0 2.47-1.37 5.79-3.11 7.53l-2.36 2.36a4.94 4.94 0 0 0-.85 5.24l.43.84A6.1 6.1 0 0 0 11.98 47H47V11.98a8.08 8.08 0 0 1 4.13-6.66l.84-.43a6.91 6.91 0 0 1 7.56 1.22l2.36 2.36A10.06 10.06 0 0 0 68 11 11 11 0 0 0 79 0h2a13 13 0 0 1-13 13 12 12 0 0 1-7.53-3.11l-2.36-2.36a4.93 4.93 0 0 0-5.24-.85l-.84.43A6.1 6.1 0 0 0 49 11.98V47h35.02a8.08 8.08 0 0 1 6.66 4.13l.43.84a6.91 6.91 0 0 1-1.22 7.56l-2.36 2.36A10.06 10.06 0 0 0 85 68a11 11 0 0 0 22 0c0-1.94-1.16-4.75-2.53-6.11l-2.36-2.36a6.93 6.93 0 0 1-1.22-7.56l.43-.84a8.08 8.08 0 0 1 6.66-4.13H143V11.98a6.1 6.1 0 0 0-3.03-4.87l-.84-.43c-1.59-.8-4-.4-5.24.85l-2.36 2.36A12 12 0 0 1 124 13a13 13 0 0 1-13-13h2a11 11 0 0 0 11 11c1.94 0 4.75-1.16 6.11-2.53l2.36-2.36a6.93 6.93 0 0 1 7.56-1.22l.84.43a8.08 8.08 0 0 1 4.13 6.66V47h35.02a6.1 6.1 0 0 0 4.87-3.03l.43-.84c.8-1.59.4-4-.85-5.24l-2.36-2.36A12 12 0 0 1 179 28a13 13 0 0 1 13-13zM84.02 143a6.1 6.1 0 0 0 4.87-3.03l.43-.84c.8-1.59.4-4-.85-5.24l-2.36-2.36A12 12 0 0 1 83 124a13 13 0 1 1 26 0c0 2.47-1.37 5.79-3.11 7.53l-2.36 2.36a4.94 4.94 0 0 0-.85 5.24l.43.84a6.1 6.1 0 0 0 4.87 3.03H143v-35.02a8.08 8.08 0 0 1 4.13-6.66l.84-.43a6.91 6.91 0 0 1 7.56 1.22l2.36 2.36A10.06 10.06 0 0 0 164 107a11 11 0 0 0 0-22c-1.94 0-4.75 1.16-6.11 2.53l-2.36 2.36a6.93 6.93 0 0 1-7.56 1.22l-.84-.43a8.08 8.08 0 0 1-4.13-6.66V49h-35.02a6.1 6.1 0 0 0-4.87 3.03l-.43.84c-.79 1.58-.4 4 .85 5.24l2.36 2.36a12.04 12.04 0 0 1 3.11 7.51A13 13 0 1 1 83 68a12 12 0 0 1 3.11-7.53l2.36-2.36a4.93 4.93 0 0 0 .85-5.24l-.43-.84A6.1 6.1 0 0 0 84.02 49H49v35.02a8.08 8.08 0 0 1-4.13 6.66l-.84.43a6.91 6.91 0 0 1-7.56-1.22l-2.36-2.36A10.06 10.06 0 0 0 28 85a11 11 0 0 0 0 22c1.94 0 4.75-1.16 6.11-2.53l2.36-2.36a6.93 6.93 0 0 1 7.56-1.22l.84.43a8.08 8.08 0 0 1 4.13 6.66V143h35.02z'%3E%3C/path%3E%3C/svg%3E");
        }
        .cover {
          filter: brightness(0.6);
        }
      }
      .cover {
        width: auto;
        height: auto;
        min-height: 100%;
        opacity: 0;
        transition:
          filter 0.3s,
          opacity 0.3s;
        &.loaded {
          opacity: 1;
        }
      }
    }
    </style>
    <div class="loading">
    <div class="loading-content">
        <div class="loading-icon">
            <i class="iconfont icon-loading"></i>
        </div>
        <div class="loading-text">加载中...</div>
    </div>
</div> <footer id="main-footer" class="main-footer">
    <div class="footer-content">
        <div class="footer-copyright">
            <span class="time" data-v-6001e979="">@ 2014 - 2025 By </span>
            <a href="https://www.imsyy.top" class="author link" target="_blank">
                飞鸿踏雪
            </a>
            
            
        </div>
        <div class="meta">
            <a class="power link" href="https://vitepress.dev/" target="_blank">
                <span class="by">Powered by</span>
                <span class="name">Hugo</span>
            </a>
            <a class="theme link" href="/pages/theme">
                <span class="name">主题</span>
            </a>
            <a class="rss link" href="https://blog.imsyy.top/rss.xml" target="_blank">
                <i class="iconfont icon-rss"></i>
                <span class="name" data-v-6001e979="">订阅</span>
            </a>
            <a class="cc link" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans" target="_blank">
                <i class="iconfont icon-line"></i>
                <i class="iconfont icon-by-line"></i>
                <i class="iconfont icon-nc-line"></i><i
                    class="iconfont icon-nd-line"></i>
            </a>
        </div>
    </div>
</footer></body>
</html> 